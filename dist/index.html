
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      :root {
        --bg-color: #121212;
        --container-bg: #1e1e1e;
        --text-color: #e0e0e0;
        --heading-color: #ffffff;
        --subheading-color: #58a6ff;
        --link-color: #58a6ff;
        --border-color: #333333;
        --item-hover: #2a2a2a;
        --shadow: 0 4px 12px rgba(0,0,0,0.2);
        --accent-color: #58a6ff;
        --tooltip-bg: #2a2a2a;
        --tooltip-text: #e0e0e0;
        --table-header-bg: #2a2a2a;
        --table-header-text: #ffffff;
        --table-row-odd: #1e1e1e;
        --table-row-even: #252525;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        line-height: 1.5;
        color: var(--text-color);
        background-color: var(--bg-color);
        margin: 0;
        padding: 0;
      }
      
      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 15px;
      }
      
      .card {
        background-color: var(--container-bg);
        border-radius: 8px;
        box-shadow: var(--shadow);
        padding: 16px;
        margin-bottom: 16px;
        transition: all 0.2s ease;
      }
      
      .card:hover {
        box-shadow: 0 6px 12px rgba(0,0,0,0.15);
      }

      .header-p {
        margin: 0.2em 0;
        font-weight: 500;
        letter-spacing: -0.02em;
        font-size: 14px;
      }

      .subreddit {
        text-align: right;
      }
      
      h2 {
        font-size: 18px;
        font-weight: 600;
        color: var(--heading-color);
        margin-top: 0;
        margin-bottom: 12px;
        padding-bottom: 6px;
        border-bottom: 2px solid var(--accent-color);
      }
      
      h3 {
        font-size: 16px;
        font-weight: 500;
        color: var(--subheading-color);
        margin-bottom: 8px;
      }
      
      a {
        color: var(--link-color);
        text-decoration: none;
        transition: color 0.2s ease;
      }
      
      a:hover {
        color: var(--accent-color);
        text-decoration: underline;
      }
      
      /* Weather Table Styles */
      .weather-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        border-radius: 6px;
        overflow: hidden;
      }
      
      .weather-table th {
        background-color: var(--table-header-bg);
        color: var(--table-header-text);
        font-weight: 500;
        text-align: left;
        padding: 8px 12px;
        font-size: 14px;
      }
      
      .weather-table td {
        padding: 8px 12px;
        border-bottom: 1px solid var(--border-color);
        font-size: 14px;
      }
      
      .weather-table tr:nth-child(odd) {
        background-color: var(--table-row-odd);
      }
      
      .weather-table tr:nth-child(even) {
        background-color: var(--table-row-even);
      }
      
      .weather-table tr:last-child td {
        border-bottom: none;
      }
      
      .comic {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 12px 0;
      }
      
      .comic-title {
        font-weight: 600;
        margin-bottom: 8px;
        text-align: center;
        font-size: 15px;
      }
      
      .comic img {
        max-width: 600px;
        max-height: auto;
        object-fit: contain;
        border-radius: 6px;
        margin-bottom: 6px;
        cursor: pointer;
      }
      
      .comic-number {
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.7;
        margin-top: 3px;
      }
      
      .item-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      
      .item-list li {
        padding: 8px 10px;
        border-bottom: 1px solid var(--border-color);
        position: relative;
        font-size: 14px;
      }
      
      .item-list li:last-child {
        border-bottom: none;
      }
      
      .item-list li:hover {
        background-color: var(--item-hover);
        border-radius: 4px;
      }
      
      .item-content {
        display: none;
        position: absolute;
        z-index: 10;
        background-color: var(--tooltip-bg);
        color: var(--tooltip-text);
        border-radius: 6px;
        padding: 15px;
        width: 90%;
        max-width: 100%;
        box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        left: 50%;
        transform: translateX(-50%);
        bottom: 100%;
        font-size: 13px;
        line-height: 1.4;
        overflow: auto;
        max-height: 250px;
        border: 4px solid var(--border-color);
      }

      .item-content::-webkit-scrollbar {
        display: none;
      }

      .item-list li:hover .item-content {
        display: block;
      }
      
      .item-list li::before {
        content: "‚Ä¢";
        color: var(--accent-color);
        font-weight: bold;
        display: inline-block;
        width: 1em;
        margin-left: -0.5em;
      }
      
      @media (max-width: 600px) {
        .container {
          padding: 10px;
        }
        
        .card {
          padding: 12px;
          margin-bottom: 12px;
        }
        
        .item-content {
          width: 95%;
          left: 2.5%;
          transform: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
  
      <div class="card">
        <h2>Huginn Daily</h2>
        <p class="header-p">Thursday, August 28, 2025</p>
        <p class="header-p">ba38ec09-89cb-4616-914a-d963143c56e8</p>
      </div>
  
      <div class="card">
        <h2>Weather</h2>
        <table class="weather-table">
          <tr>
            <th>Summary</th>
            <td>‚õÖÔ∏è Clear throughout the day.</td>
          </tr>
          <tr>
            <th>Temperature Range</th>
            <td>23¬∞C to 31¬∞C (73¬∞F to 87¬∞F)</td>
          </tr>
          <tr>
            <th>Feels Like</th>
            <td>Low: 72¬∞F | High: 84¬∞F</td>
          </tr>
          <tr>
            <th>Humidity</th>
            <td>48%</td>
          </tr>
          <tr>
            <th>Wind</th>
            <td>11 km/h (7 mph), Direction: 224¬∞</td>
          </tr>
          <tr>
            <th>Precipitation</th>
            <td>Probability: 0%, Type: No precipitation expected</td>
          </tr>
          <tr>
            <th>Sunrise / Sunset</th>
            <td>üåÖ 06:18 AM / üåá 07:19 PM</td>
          </tr>
          <tr>
            <th>Moon Phase</th>
            <td>Waxing Crescent (17%)</td>
          </tr>
          <tr>
            <th>Cloud Cover</th>
            <td>0%</td>
          </tr>
          <tr>
            <th>Pressure</th>
            <td>1008.62 hPa</td>
          </tr>
          <tr>
            <th>Dew Point</th>
            <td>57.63¬∞F</td>
          </tr>
          <tr>
            <th>Visibility</th>
            <td>10.0 miles</td>
          </tr>
        </table>
      </div>
  
      <div class="card">
        <h2>XKCD</h2>
  
        <div class="comic">
          <a href="//imgs.xkcd.com/comics/wavefunction_collapse.png" target="_blank">
            <img src="//imgs.xkcd.com/comics/wavefunction_collapse.png" alt="Wavefunction Collapse">
          </a>
        </div>
  
      </div>
  
      <div class="card">
        <h2>Golang</h2>
        <ul class="item-list">
  
          <li>
            <a href="https://go.dev/blog/testing-time" target="_blank">Testing Time (and other asyncronicities)</a>
            <div class="item-content">
<div id="blog"><div id="content">
  <div id="content">

    <div class="Article" data-slug="/blog/testing-time">
    
    <h1 class="small"><a href="/blog/">The Go Blog</a></h1>
    

    <h1>Testing Time (and other asyncronicities)</h1>
      
      <p class="author">
      Damien Neil<br>
      26 August 2025
      </p>
      
      <div class='markdown'>
<p>In Go 1.24, we introduced the <a href="/pkg/testing/synctest"><code>testing/synctest</code></a>
package as an experimental package.
This package can significantly simplify writing tests for concurrent,
asynchronous code.
In Go 1.25, the <code>testing/synctest</code> package has graduated from experiment
to general availability.</p>
<p>What follows is the blog version of my talk on
the <a href="/pkg/testing/synctest"><code>testing/synctest</code></a> package
at GopherCon Europe 2025 in Berlin.</p>
<h2 id="what-is-an-asynchronous-function">What is an asynchronous function?</h2>
<p>A synchronous function is pretty simple.
You call it, it does something, and it returns.</p>
<p>An asynchronous function is different.
You call it, it returns, and then it does something.</p>
<p>As a concrete, if somewhat artificial, example,
the following <code>Cleanup</code> function is synchronous.
You call it, it deletes a cache directory, and it returns.</p>
<pre><code>func (c *Cache) Cleanup() {
    os.RemoveAll(c.cacheDir)
}
</code></pre>
<p><code>CleanupInBackground</code> is an asynchronous function.
You call it, it returns, and the cache directory is deleted&hellip;sooner or later.</p>
<pre><code>func (c *Cache) CleanupInBackground() {
    go os.RemoveAll(c.cacheDir)
}
</code></pre>
<p>Sometimes an asynchronous function does something in the future.
For example, the <code>context</code> package&rsquo;s <code>WithDeadline</code> function
returns a context which will be canceled in the future.</p>
<pre><code>package context

// WithDeadline returns a derived context
// with a deadline no later than d.
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
</code></pre>
<p>When I talk about testing concurrent code,
I mean testing these sorts of asynchronous operations,
both ones which use real time and ones which do not.</p>
<h2 id="tests">Tests</h2>
<p>A test verifies that a system behaves as we expect.
There&rsquo;s a lot of terminology describing types
of test&ndash;unit tests, integration tests, and so on&ndash;but
for our purposes here every kind of test reduces to three steps:</p>
<ol>
<li>Set up some initial conditions.</li>
<li>Tell the system under test to do something.</li>
<li>Verify the result.</li>
</ol>
<p>Testing a synchronous function is straightforward:</p>
<ul>
<li>You call the function;</li>
<li>the function does something and returns;</li>
<li>you verify the result.</li>
</ul>
<p>Testing an asyncronous function, however, is tricky:</p>
<ul>
<li>You call the function;</li>
<li>it returns;</li>
<li>you wait for it to finish doing whatever it does;</li>
<li>you verify the result.</li>
</ul>
<p>If you don&rsquo;t wait for the correct amount of time,
you may find yourself verifying the result of an operation that hasn&rsquo;t happened yet
or has only happened partially.
This never ends well.</p>
<p>Testing an asynchronous function is especially tricky
when you want to assert that something has <em>not</em> happened.
You can verify that the thing has not happened yet,
but how do you know with certainty that it isn&rsquo;t going to happen later?</p>
<h2 id="an-example">An example</h2>
<p>To make things a little more concrete,
let&rsquo;s work with a real-world example.
Consider the <code>context</code> package&rsquo;s <code>WithDeadline</code> function again.</p>
<pre><code>package context

// WithDeadline returns a derived context
// with a deadline no later than d.
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
</code></pre>
<p>There are two obvious tests to write for <code>WithDeadline</code>.</p>
<ol>
<li>The context is <em>not</em> canceled <em>before</em> the deadline.</li>
<li>The context <em>is</em> canceled <em>after</em> the deadline.</li>
</ol>
<p>Let&rsquo;s write a test.</p>
<p>To keep the amount of code marginally less overwhelming,
we&rsquo;ll just test the second case:
After the deadline expires, the context is canceled.</p>
<pre><code>func TestWithDeadlineAfterDeadline(t *testing.T) {
    deadline := time.Now().Add(1 * time.Second)
    ctx, _ := context.WithDeadline(t.Context(), deadline)

    time.Sleep(time.Until(deadline))

    if err := ctx.Err(); err != context.DeadlineExceeded {
        t.Fatalf(&quot;context not canceled after deadline&quot;)
    }
}
</code></pre>
<p>This test is simple:</p>
<ol>
<li>Use <code>context.WithDeadline</code> to create a context with a deadline one second in the future.</li>
<li>Wait until the deadline.</li>
<li>Verify that the context is canceled.</li>
</ol>
<p>Unfortunately, this test obviously has a problem.
It sleeps until the exact moment the deadline expires.
Odds are good that the context has not been canceled yet by the time we examine it.
At best, this test will be very flaky.</p>
<p>Let&rsquo;s fix it.</p>
<pre><code>time.Sleep(time.Until(deadline) + 100*time.Millisecond)
</code></pre>
<p>We can sleep until 100ms after the deadline.
A hundred milliseconds is an eternity in computer terms.
This should be fine.</p>
<p>Unfortunately, we still have two problems.</p>
<p>First, this test takes 1.1 seconds to execute.
That&rsquo;s slow.
This is a simple test.
It should execute in milliseconds at the most.</p>
<p>Second, this test is flaky.
A hundred milliseconds is an eternity in computer terms,
but on an overloaded continuous integration (CI) system
it isn&rsquo;t unusual to see pauses much longer than that.
This test will probably pass consistently on a developer&rsquo;s workstation,
but I would expect occasional failures in a CI system.</p>
<h2 id="slow-or-flaky-pick-two">Slow or flaky: Pick two</h2>
<p>Tests that use real time are always slow or flaky.
Usually they&rsquo;re both.
If the test waits longer than necessary, it is slow.
If it doesn&rsquo;t wait long enough, it is flaky.
You can make the test more slow and less flaky,
or less slow and more flaky,
but you can&rsquo;t make it fast and reliable.</p>
<p>We have a lot of tests in the <code>net/http</code> package which use this approach.
They&rsquo;re all slow and/or flaky, which is what started me down the road
which brings us here today.</p>
<h2 id="write-synchronous-functions">Write synchronous functions?</h2>
<p>The simplest way to test an asyncronous function is not to do it.
Synchronous functions are easy to test.
If you can transform an asyncronous function into a synchronous one,
it will be easier to test.</p>
<p>For example, if we consider our cache cleanup functions from earlier,
the synchronous <code>Cleanup</code> is obviously better than
the asynchronous <code>CleanupInBackground</code>.
The synchronous function is easier to test,
and the caller can easily start a new goroutine to run it in the background if needed.
As a general rule,
the higher up the call stack you can push your concurrency,
the better.</p>
<pre><code>// CleanupInBackground is hard to test.
cache.CleanupInBackground()

// Cleanup is easy to test,
// and easy to run in the background when needed.
go cache.Cleanup()
</code></pre>
<p>Unfortunately, this sort of transformation isn&rsquo;t always possible.
For example, <code>context.WithDeadline</code> is an inherently asynchronous API.</p>
<h2 id="instrument-code-for-testability">Instrument code for testability?</h2>
<p>A better approach is to make our code more testable.</p>
<p>Here&rsquo;s an example of what this might look like for our <code>WithDeadline</code> test:</p>
<pre><code>func TestWithDeadlineAfterDeadline(t *testing.T) {
    clock := fakeClock()
    timeout := 1 * time.Second
    deadline := clock.Now().Add(timeout)

    ctx, _ := context.WithDeadlineClock(
        t.Context(), deadline, clock)

    clock.Advance(timeout)
    context.WaitUntilIdle(ctx)
    if err := ctx.Err(); err != context.DeadlineExceeded {
        t.Fatalf(&quot;context not canceled after deadline&quot;)
    }
}
</code></pre>
<p>Instead of using real time, we use a fake time implementation.
Using fake time avoids unnecessarily slow tests,
because we never wait around doing nothing.
It also helps avoid test flakiness,
since the current time only changes when the test adjusts it.</p>
<p>There are various fake time packages out there,
or you can write your own.</p>
<p>To use fake time, we need to modify our API to accept a fake clock.
I&rsquo;ve added a <code>context.WithDeadlineClock</code> function here,
that takes an additional clock parameter:</p>
<pre><code>ctx, _ := context.WithDeadlineClock(
    t.Context(), deadline, clock)
</code></pre>
<p>When we advance our fake clock, we have a problem.
Advancing time is an asynchrounous operation.
Sleeping goroutines may wake up,
timers may send on their channels,
and timer functions may run.
We need to wait for that work to finish before we can test
the expected behavior of the system.</p>
<p>I&rsquo;ve added a <code>context.WaitUntilIdle</code> function here,
which waits for any background work related to a context to complete:</p>
<pre><code>clock.Advance(timeout)
context.WaitUntilIdle(ctx)
</code></pre>
<p>This is a simple example, but it demonstrates
the two fundamental principles of writing testable concurrent code:</p>
<ol>
<li>Use fake time (if you use time).</li>
<li>Have some way to wait for quiescence,
which is a fancy way of saying
&ldquo;all background activity has stopped and the system is stable&rdquo;.</li>
</ol>
<p>The interesting question, of course, is how we do this.
I&rsquo;ve glossed over the details in this example because
there are some big downsides to this approach.</p>
<p>It&rsquo;s hard.
Using a fake clock isn&rsquo;t difficult,
but identifying when background concurrent work is finished
and it is safe to examine the state of the system is.</p>
<p>Your code becomes less idiomatic.
You can&rsquo;t use standard time package functions.
You need to be very careful to keep track of everything happening
in the background.</p>
<p>You need to instrument not just your code,
but any other packages you use.
If you call any third-party concurrent code,
you&rsquo;re probably out of luck.</p>
<p>Worst of all, it can be just about impossible
to retrofit this approach into an existing codebase.</p>
<p>I attempted to apply this approach to Go&rsquo;s HTTP implementation,
and while I had some success at doing so in places,
the HTTP/2 server simply defeated me.
In particular, adding instrumentation to detect quiescence
without extensive rewriting proved infeasible,
or at least beyond my skills.</p>
<h2 id="horrible-runtime-hacks">Horrible runtime hacks?</h2>
<p>What do we do if we can&rsquo;t make our code testable?</p>
<p>What if instead of instrumenting our code,
we had a way to observe the behavior of the uninstrumented system?</p>
<p>A Go program consists of a set of goroutines.
Those goroutines have states.
We just need to wait until all the goroutines have stopped running.</p>
<p>Unfortunately, the Go runtime doesn&rsquo;t provide any way to tell what
those goroutines are doing. Or does it?</p>
<p>The <code>runtime</code> package contains a function that gives us a stack trace
for every running goroutine, as well as their states.
This is text intended for human consumption,
but we could parse that output.
Could we use this to detect quiescence?</p>
<p>Now, of course this is a terrible idea.
There is no guarantee that the format of these stack traces will be stable over time.
You should not do this.</p>
<p>I did it.
And it worked.
In fact, it worked surprisingly well.</p>
<p>With a simple implementation of a fake clock,
a small amount of instrumentation to keep track of what goroutines were part of the test,
and some horrifying abuse of <code>runtime.Stack</code>,
I finally had a way to write fast, reliable tests for the <code>http</code> package.</p>
<p>The underlying implementation of these tests was horrible,
but it demonstrated that there was a useful concept here.</p>
<h2 id="a-better-way">A better way</h2>
<p>Go may have built-in concurrency,
but testing programs that use that concurrency is hard.</p>
<p>We&rsquo;re faced with an unfortunate choice:
We can write simple, idiomatic code, but it will be impossible to test quickly and reliably;
or we can write testable code, but it will be complicated and unidiomatic.</p>
<p>So we asked ourselves what we can do to make this better.</p>
<p>As we saw earlier, the two fundamental features required to write testable concurrent code are
fake time and a way to wait for quiescence.</p>
<p>We need a better way to to wait for quiescence.
We should be able to ask the runtime when background goroutines have finished their work.
We also want to be able to limit the scope of this query to a single test,
so that unrelated tests do not interfere with each other.</p>
<p>We also need better support for testing programs using fake time.</p>
<p>It isn&rsquo;t hard to make a fake time implementation,
but code which uses an implementation like this is not idiomatic.</p>
<p>Idiomatic code will use a <code>time.Timer</code>,
but it is not possible to create a fake <code>Timer</code>.
We asked ourselves whether we should provide a way for tests to
create a fake <code>Timer</code>, where the test controls when the timer fires.</p>
<p>A testing implementation of time needs to define an entirely new version of the <code>time</code> package,
and pass that to every function that operates on time.
We considered whether we should define a common time interface,
in the same way that <code>net.Conn</code> is a common interface describing a network connection.</p>
<p>What we realized, however, is that unlike network connections,
there is only one possible implementation of fake time.
A fake network may want to introduce latency or errors.
Time, in contrast, does only one thing: It moves forward.
Tests need to control the rate at which time progresses,
but a timer scheduled to fire ten seconds in the future
should always fire ten (possibly fake) seconds in the future.</p>
<p>In addition, we don&rsquo;t want to upset the entire Go ecosystem.
Most programs today use functions in the time package.
We want to keep those programs not only working,
but idiomatic.</p>
<p>This led to the conclusion that what we need is a way for a test to
tell the time package to use a fake clock,
in much the same way that the Go playground uses a fake clock.
Unlike the playground,
we need to limit the scope of that change to a single test.
(It may not be obvious that the Go playground uses a fake clock,
because we turn any fake delays into real delays on the front end,
but it does.)</p>
<h2 id="the-synctest-experiment">The <code>synctest</code> experiment</h2>
<p>And so in Go 1.24 we introduced <a href="/pkg/testing/synctest"><code>testing/synctest</code></a>,
a new, experimental package to simplify testing concurrent programs.
Over the months following the release of Go 1.24
we gathered feedback from early adopters.
(Thank you to everyone who tried it out!)
We made a number of changes to address problems and shortcomings.
And now, in Go 1.25, we&rsquo;ve released the <code>testing/synctest</code> package
as part of the standard library.</p>
<p>It lets you run a function in what we&rsquo;re calling a &ldquo;bubble&rdquo;.
Within the bubble, the time package uses a fake clock,
and the <code>synctest</code> package provides a function to wait for the bubble to quiesce.</p>
<h2 id="the-synctest-package">The <code>synctest</code> package</h2>
<p>The <code>synctest</code> package contains just two functions.</p>
<pre><code>package synctest

// Test executes f in a new bubble.
// Goroutines in the bubble use a fake clock.
func Test(t *testing.T, f func(*testing.T))

// Wait waits for background activity in the bubble to complete.
func Wait()
</code></pre>
<p><a href="/pkg/testing/synctest#Test"><code>Test</code></a> executes a function in a new bubble.</p>
<p><a href="/pkg/testing/synctest#Wait"><code>Wait</code></a> blocks until every goroutine in the bubble is blocked
waiting for some other goroutine in the bubble.
We call that state being &ldquo;durably blocked&rdquo;.</p>
<h2 id="testing-with-synctest">Testing with synctest</h2>
<p>Let&rsquo;s look at an example of synctest in action.</p>
<pre><code>func TestWithDeadlineAfterDeadline(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        deadline := time.Now().Add(1 * time.Second)
        ctx, _ := context.WithDeadline(t.Context(), deadline)

        time.Sleep(time.Until(deadline))
        synctest.Wait()
        if err := ctx.Err(); err != context.DeadlineExceeded {
            t.Fatalf(&quot;context not canceled after deadline&quot;)
        }
    })
}
</code></pre>
<p>This might look a little familiar.
This is the na√Øve test for <code>context.WithDeadline</code> that we looked at earlier.
The only changes are that we&rsquo;ve wrapped the test in
a <code>synctest.Test</code> call to execute it in a bubble
and we have added a <code>synctest.Wait</code> call.</p>
<p>This test is fast and reliable.
It runs almost instantaneously.
It precisely tests the expected behavior of the system under test.
It also requires no modification of the <code>context</code> package.</p>
<p>Using the <code>synctest</code> package,
we can write simple, idiomatic code
and test it reliably.</p>
<p>This is a very simple example, of course,
but this is a real test of real production code.
If <code>synctest</code> had existed when the <code>context</code> package was written,
we would have had a much easier time writing tests for it.</p>
<h2 id="time">Time</h2>
<p>Time in the bubble behaves much the same as the fake time in the Go playground.
Time starts at midnight, January 1, 2000 UTC.
If you need to run a test at some specific point in time for some reason,
you can just sleep until then.</p>
<pre><code>func TestAtSpecificTime(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       // 2000-01-01 00:00:00 +0000 UTC
       t.Log(time.Now().In(time.UTC))

       // This does not take 25 years.
       time.Sleep(time.Until(
           time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)))

       // 2025-01-01 00:00:00 +0000 UTC
       t.Log(time.Now().In(time.UTC))
   })
}
</code></pre>
<p>Time only passes when every goroutine in the bubble has blocked.
You can think of the bubble as simulating an infinitely fast computer:
Any amount of computation takes no time.</p>
<p>The following test will always print that zero seconds
of fake time have elapsed since the start of the test,
no matter how much real time has passed.</p>
<pre><code>func TestExpensiveWork(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       start := time.Now()
       for range 1e7 {
           // do expensive work
       }
       t.Log(time.Since(start)) // 0s
   })
}
</code></pre>
<p>In the next test, the <code>time.Sleep</code> call will return immediately,
rather than waiting for ten real seconds.
The test will always print that exactly ten fake seconds
have passed since the start of the test.</p>
<pre><code>func TestSleep(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       start := time.Now()
       time.Sleep(10 * time.Second)
       t.Log(time.Since(start)) // 10s
   })
}
</code></pre>
<h2 id="waiting-for-quiescence">Waiting for quiescence</h2>
<p>The <a href="/pkg/testing/synctest#Wait"><code>synctest.Wait</code></a> function
lets us wait for background activity to complete.</p>
<pre><code>func TestWait(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       done := false
       go func() {
           done = true
       }()

       // Wait for the above goroutine to finish.
       synctest.Wait()

       t.Log(done) // true
   })
}
</code></pre>
<p>If we didn&rsquo;t have the <code>Wait</code> call in the above test,
we would have a race condition:
One goroutine modifies the <code>done</code> variable
while another reads from it without synchronization.
The <code>Wait</code> call provides that synchronization.</p>
<p>You may be familiar with the <code>-race</code> test flag,
which enables the data race detector.
The race detector is aware of the synchronization provided by <code>Wait</code>,
and does not complain about this test.
If we forgot the <code>Wait</code> call, the race detector would correctly complain.</p>
<p>The <code>synctest.Wait</code> function provides synchronization,
but the passage of time does not.</p>
<p>In the next example, one goroutine writes to the <code>done</code> variable
while another sleeps for one nanosecond before reading from it.
It should be obvious that when run with a real clock outside a synctest bubble,
this code contains a race condition.
Inside a synctest bubble,
while the fake clock ensures that the goroutine completes before <code>time.Sleep</code> returns,
the race detector will still report the data race,
just like it would if this code were run outside a synctest bubble.</p>
<pre><code>func TestTimeDataRace(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       done := false
       go func() {
           done = true // write
       }()

       time.Sleep(1 * time.Nanosecond)

       t.Log(done)     // read (unsynchronized)
   })
}
</code></pre>
<p>Adding a <code>Wait</code> call provides explicit synchronization and fixes the data race:</p>
<pre><code>time.Sleep(1 * time.Nanosecond)
synctest.Wait() // synchronize
t.Log(done)     // read
</code></pre>
<h2 id="example-iocopy">Example: <code>io.Copy</code></h2>
<p>Taking advantage of the synchronization provided by <code>synctest.Wait</code> allows us
to write simpler tests with less explicit synchronization.</p>
<p>For example, consider this test of <a href="/pkg/io#Copy"><code>io.Copy</code></a>.</p>
<pre><code>func TestIOCopy(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       srcReader, srcWriter := io.Pipe()
       defer srcWriter.Close()

       var dst bytes.Buffer
       go io.Copy(&amp;dst, srcReader)

       data := &quot;1234&quot;
       srcWriter.Write([]byte(&quot;1234&quot;))
       synctest.Wait()

       if got, want := dst.String(), data; got != want {
           t.Errorf(&quot;Copy wrote %q, want %q&quot;, got, want)
       }
   })
}
</code></pre>
<p>The <code>io.Copy</code> function copies data from an <code>io.Reader</code> to an <code>io.Writer</code>.
You might not immediately think of <code>io.Copy</code> as a concurrent function,
since it blocks until the copy has completed.
However, providing data to <code>io.Copy</code>&rsquo;s reader is an asynchronous operation:</p>
<ul>
<li><code>Copy</code> calls the reader&rsquo;s <code>Read</code> method;</li>
<li><code>Read</code> returns some data;</li>
<li>and the data is written to the writer at a later time.</li>
</ul>
<p>In this test, we are verifying that <code>io.Copy</code> writes new data to the writer
without waiting to fill its buffer.</p>
<p>Looking at the test step by step,
we first create an <code>io.Pipe</code> to serve as the source <code>io.Copy</code> reads from:</p>
<pre><code>srcReader, srcWriter := io.Pipe()
defer srcWriter.Close()
</code></pre>
<p>We call <code>io.Copy</code> in a new goroutine,
copying from the read end of the pipe into a <code>bytes.Buffer</code>:</p>
<pre><code>var dst bytes.Buffer
go io.Copy(&amp;dst, srcReader)
</code></pre>
<p>We write to the other end of the pipe,
and wait for <code>io.Copy</code> to handle the data:</p>
<pre><code>data := &quot;1234&quot;
srcWriter.Write([]byte(&quot;1234&quot;))
synctest.Wait()
</code></pre>
<p>Finally, we verify that the destination buffer contains the desired data:</p>
<pre><code>if got, want := dst.String(), data; got != want {
    t.Errorf(&quot;Copy wrote %q, want %q&quot;, got, want)
}
</code></pre>
<p>We don&rsquo;t need to add a mutex or other synchronization around the destination buffer,
because <code>synctest.Wait</code> ensures that it is never accessed concurrently.</p>
<p>This test demonstrates a few important points.</p>
<p>Even synchronous functions like <code>io.Copy</code>,
which do not perform additional background work after they return,
may exhibit asynchronous behaviors.</p>
<p>Using <code>synctest.Wait</code>, we can test those behaviors.</p>
<p>Note also that this test does not work with time.
Many asynchronous systems involve time, but not all.</p>
<h2 id="bubble-exit">Bubble exit</h2>
<p>The <code>synctest.Test</code> function waits for all goroutines in the bubble to exit
before returning.
Time stops advancing after the root goroutine (the goroutine started by <code>Test</code>) returns.</p>
<p>In the next example, <code>Test</code> waits for the background goroutine to run and exit
before it returns:</p>
<pre><code>func TestWaitForGoroutine(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        go func() {
            // This runs before synctest.Test returns.
        }()
    })
}
</code></pre>
<p>In this example, we schedule a <code>time.AfterFunc</code> for a time in the future.
The bubble&rsquo;s root goroutine returns before that time is reached,
so the <code>AfterFunc</code> never runs:</p>
<pre><code>func TestDoNotWaitForTimer(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        time.AfterFunc(1 * time.Nanosecond, func() {
            // This never runs.
        })
    })
}
</code></pre>
<p>In the next example, we start a goroutine that sleeps.
The root goroutine returns and time stops advancing.
The bubble is now deadlocked,
because <code>Test</code> is waiting for all goroutines in the bubble to finish
but the sleeping goroutine is waiting for time to advance.</p>
<pre><code>func TestDeadlock(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        go func() {
            // This sleep never returns and the test deadlocks.
            time.Sleep(1 * time.Nanosecond)
        }()
    })
}
</code></pre>
<h2 id="deadlocks">Deadlocks</h2>
<p>The <code>synctest</code> package panics when a bubble is deadlocked
due to every goroutine in the bubble being durably blocked on
another goroutine in the bubble.</p>
<pre><code>--- FAIL: Test (0.00s)
--- FAIL: TestDeadlock (0.00s)
panic: deadlock: main bubble goroutine has exited but blocked goroutines remain [recovered, repanicked]

goroutine 7 [running]:
(stacks elided for clarity)

goroutine 10 [sleep (durable), synctest bubble 1]:
time.Sleep(0x1)
    /Users/dneil/src/go/src/runtime/time.go:361 +0x130
_.TestDeadlock.func1.1()
    /tmp/s/main_test.go:13 +0x20
created by _.TestDeadlock.func1 in goroutine 9
    /tmp/s/main_test.go:11 +0x24
FAIL    _   0.173s
FAIL
</code></pre>
<p>The runtime will print stack traces for every goroutine in the deadlocked bubble.</p>
<p>When printing the status of a bubbled goroutine,
the runtime indicates when the goroutine is durably blocked.
You can see that the sleeping goroutine in this test is durably blocked.</p>
<h2 id="durable-blocking">Durable blocking</h2>
<p>&ldquo;Durably blocking&rdquo; is a core concept in synctest.</p>
<p>A goroutine is durably blocked when it is not only blocked,
but when it can only be unblocked by another goroutine in the same bubble.</p>
<p>When every goroutine in a bubble is durably blocked:</p>
<ol>
<li><code>synctest.Wait</code> returns.</li>
<li>If there is no <code>synctest.Wait</code> call in progress,
fake time advances instantly to the next point that will wake a goroutine.</li>
<li>If there is no goroutine that can be woken by advancing time,
the bubble is deadlocked and the test fails.</li>
</ol>
<p>It is important for us to make a distinction between a goroutine which is merely blocked
and one which is <em>durably</em> blocked.
We don&rsquo;t want to declare a deadlock when a goroutine is temporarily blocked on
some event arising outside its bubble.</p>
<p>Let&rsquo;s look at some ways in which a goroutine can block non-durably.</p>
<h3 id="not-durably-blocking-io-files-pipes-network-connections-etc">Not durably blocking: I/O (files, pipes, network connections, etc.)</h3>
<p>The most important limitation is that I/O is not durably blocking,
including network I/O.
A goroutine reading from a network connection may be blocked,
but it will be unblocked by data arriving on that connection.</p>
<p>This is obviously true for a connection to some network service,
but it is also true for a loopback connection,
even when the reader and writer are both in the same bubble.</p>
<p>When we write data to a network socket,
even a loopback socket,
the data is passed to the kernel for delivery.
There is a period of time between the write system call returning
and the kernel notifying the other side of the connection that data is available.
The Go runtime cannot distinguish between a goroutine blocked waiting for
data that is already in the kernel&rsquo;s buffers
and one blocked waiting for data that will not arrive.</p>
<p>This means that tests of networked programs using synctest
usually cannot use real network connections.
Instead, they should use an in-memory fake.</p>
<p>I&rsquo;m not going to go over the process of creating a fake network here,
but the <code>synctest</code> package documentation contains
<a href="/pkg/testing/synctest#hdr-Example__HTTP_100_Continue">a complete worked example</a>
of testing an HTTP client and server communicating over a fake network.</p>
<h3 id="not-durably-blocking-syscalls-cgo-calls-anything-that-isnt-go">Not durably blocking: syscalls, cgo calls, anything that isn&rsquo;t Go</h3>
<p>Syscalls and cgo calls are not durably blocking.
We can only reason about the state of goroutines executing Go code.</p>
<h3 id="not-durably-blocking-mutexes">Not durably blocking: Mutexes</h3>
<p>Perhaps surprisingly, mutexes are not durably blocking.
This is a decision born of practicality:
Mutexes are often used to guard global state,
so a bubbled goroutine will often need to acquire a mutex held outside its bubble.
Mutexes are highly performance-sensitive,
so adding additional instrumentation to them
risks slowing down non-test programs.</p>
<p>We can test programs that use mutexes with synctest,
but the fake clock will not advance while a goroutine is blocked on mutex acquisition.
This hasn&rsquo;t posed a problem in any case we&rsquo;ve encountered,
but it is something to be aware of.</p>
<h3 id="durably-blocking-timesleep">Durably blocking: <code>time.Sleep</code></h3>
<p>So what is durably blocking?</p>
<p><code>time.Sleep</code> is obviously durable,
since time can only advance when every goroutine in the bubble is durably blocked.</p>
<h3 id="durably-blocking-send-or-receive-on-channels-created-in-the-same-bubble">Durably blocking: send or receive on channels created in the same bubble</h3>
<p>Channel operations on channels created within the same bubble are durable.</p>
<p>We make a distinction between bubbled channels (created in a bubble)
and unbubbled channels (created outside any bubble).
This means that a function using a global channel for synchronization,
for example to control access to a globally cached resource,
can be safely called from within a bubble.</p>
<p>Trying to operate on a bubbled channel from outside its bubble is an error.</p>
<h3 id="durably-blocking-syncwaitgroup-belonging-to-the-same-bubble">Durably blocking: <code>sync.WaitGroup</code> belonging to the same bubble</h3>
<p>We also associate <code>sync.WaitGroup</code>s with bubbles.</p>
<p><code>WaitGroup</code> doesn&rsquo;t have a constructor,
so we make the association with the bubble implicitly on the first call to <code>Go</code> or <code>Add</code>.</p>
<p>As with channels,
waiting on a <code>WaitGroup</code> belonging to the same bubble is durably blocking,
and waiting on one from outside the bubble is not.
Calling <code>Go</code> or <code>Add</code> on a <code>WaitGroup</code> belonging to a different bubble is an error.</p>
<h3 id="durably-blocking-synccondwait">Durably blocking: <code>sync.Cond.Wait</code></h3>
<p>Waiting on a <code>sync.Cond</code> is always durably blocking.
Waking up a goroutine waiting on a <code>Cond</code> in a different bubble is an error.</p>
<h3 id="durably-blocking-select">Durably blocking: <code>select{}</code></h3>
<p>Finally, an empty select is durably blocking.
(A select with cases is durably blocking if all the operations in it are so.)</p>
<p>That&rsquo;s the complete list of durably blocking operations.
It isn&rsquo;t very long,
but it&rsquo;s enough to handle almost all real-world programs.</p>
<p>The rule is that a goroutine is durably blocked when it is blocked,
and we can guarantee that it can only be unblocked
by another goroutine in its bubble.</p>
<p>In cases where it is possible to attempt to wake a bubbled goroutine from outside its bubble,
we panic.
For example, it is an error to operate on a bubbled channel from outside its bubble.</p>
<h2 id="changes-from-124-to-125">Changes from 1.24 to 1.25</h2>
<p>We released an experimental version of the <code>synctest</code> package in Go 1.24.
To ensure that early adopters were aware of the experimental status of the package,
you needed to set a GOEXPERIMENT flag to make the package visible.</p>
<p>The feedback we received from those early adopters was invaluable,
both in demonstrating that the package is useful
and in uncovering areas where the API needed work.</p>
<p>These are some of the changes made between the experimental version
and the version released in Go 1.25.</p>
<h3 id="replaced-run-with-test">Replaced Run with Test</h3>
<p>The original version of the API created a bubble with a <code>Run</code> function:</p>
<pre><code>// Run executes f in a new bubble.
func Run(f func())
</code></pre>
<p>It became clear that we needed a way to create a <code>*testing.T</code>
that is scoped to a bubble.
For example, <code>t.Cleanup</code> should run cleanup functions in the same bubble
they are registered in, not after the bubble exits.
We renamed <code>Run</code> to <code>Test</code> and made it create a <code>T</code> scoped to the lifetime
of the new bubble.</p>
<h3 id="time-stops-when-a-bubbles-root-goroutine-returns">Time stops when a bubble&rsquo;s root goroutine returns</h3>
<p>We originally continued to advance time within a bubble for so long as
the bubble contained any goroutines waiting for future events.
This turned out to be very confusing when a long-lived goroutine never returned,
such as a goroutine reading forever from a <code>time.Ticker</code>.
We now stop advancing time when a bubble&rsquo;s root goroutine returns.
If the bubble is blocked waiting for time to advance,
this results in a deadlock and a panic which can be analyzed.</p>
<h3 id="removed-cases-where-durable-wasnt">Removed cases where &ldquo;durable&rdquo; wasn&rsquo;t</h3>
<p>We cleaned up the definition of &ldquo;durably blocking&rdquo;.
The original implementation had cases where a durably blocked goroutine could
be unblocked from outside the bubble.
For example, channels recorded whether they were created in a bubble,
but not which in which bubble they were created,
so one bubble could unblock a channel in a different bubble.
The current implementation contains no cases we know of
where a durably blocked goroutine can be unblocked from outside its bubble.</p>
<h3 id="better-stack-traces">Better stack traces</h3>
<p>We made improvements to the information printed in stack traces.
When a bubble deadlocks, we by default now only print stacks for the goroutines in tha bubble.
Stack traces also clearly indicate which goroutines in a bubble are durably blocked.</p>
<h3 id="randomized-events-happening-at-the-same-time">Randomized events happening at the same time</h3>
<p>We made improvements to the randomization of events happening at the same time.
Originally, timers scheduled to fire at the same instant
would always do so in the order they were created.
This ordering is now randomized.</p>
<h2 id="future-work">Future work</h2>
<p>We&rsquo;re pretty happy with the synctest package at the moment.</p>
<p>Aside from the inevitable bug fixes,
we don&rsquo;t currently expect any major changes to it in the future.
Of course, with wider adoption it is always possible that we&rsquo;ll discover something
that needs doing.</p>
<p>One possible area of work is to improve the detection of durably blocked goroutines.
It would be nice if we could make mutex operations durably blocking,
with a restriction that a mutex acquired in a bubble must be released
from within the same bubble.</p>
<p>Testing networked code with synctest requires a fake network.
The <code>net.Pipe</code> function can create a fake <code>net.Conn</code>,
but there is currently no standard library function that creates
a fake <code>net.Listener</code> or <code>net.PacketConn</code>.
In addition, the <code>net.Conn</code> returned by <code>net.Pipe</code> is synchronous&ndash;every write blocks
until a read consumes the data&ndash;which is not representative of real network behavior.
Perhaps we should add a good fake implementations of common network interfaces
to the standard library.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That&rsquo;s the <code>synctest</code> package.</p>
<p>I can&rsquo;t say that it makes testing concurrent code simple,
because concurrency is never simple.
What it does is let you write the simplest possible concurrent code,
using idiomatic Go,
and the standard time package,
and then write fast, reliable tests for it.</p>
<p>I hope you find it useful.</p>
</div>

    </div>

    
    <div class="Article prevnext">
    
    
      
        <p>
        
        
          
            <b>Previous article: </b><a href="/blog/container-aware-gomaxprocs">Container-aware GOMAXPROCS</a><br>
          
        
        <b><a href="/blog/all">Blog Index</a></b>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    </div>
    

  </div>
</div>

<script src="/js/play.js"></script>

</div>
          </li>
  
        </ul>
      </div>
  
      <div class="card">
        <h2>Reddit</h2>
  
        <h3 class="subreddit">r/rust</h3>
        <ul class="item-list">
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n211pj/built_my_first_rust_app_local_ai_orchestration/" target="_blank">Built my first Rust app: Local AI orchestration with cloud synthesis</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Just shipped <a href="https://github.com/gitcoder89431/agentic">https://github.com/gitcoder89431/agentic</a> - a TUI that orchestrates local models (Ollama) with cloud models (OpenRouter) for collaborative AI research. Turns out Rust&#39;s ownership model is perfect for managing AI token streams.</p> <p>Stack: ratatui + tokio + reqwest + serde + thiserror for the error taxonomy. The async orchestration handles local model streaming while maintaining UI responsiveness:</p> <pre><code> pub async fn orchestrate_query(&amp;mut self, query: &amp;str) -&gt; Result&lt;Vec&lt;QueryProposal&gt;, OrchestrationError&gt; { let local_stream = self.local_client .stream_query(query) .await?; let mut proposals = Vec::new(); while let Some(chunk) = local_stream.next().await { let chunk = chunk?; self.update_ui_tokens(chunk.tokens); if let Some(proposal) = chunk.proposal { proposals.push(proposal); self.render_partial_update()?; } } Ok(proposals) } </code></pre> <p>What surprised me most: Rust&#39;s ownership model naturally enforces the memory discipline needed for long-running agent workflows. No GC pauses during AI inference, bounded token counting, and the borrow checker caught several potential state corruption bugs early. The type system made the local/cloud model abstraction clean and the error handling forced me to think through failure modes upfront. The constitutional &quot;no unwrap in production&quot; rule felt restrictive at first, but resulted in much more robust error recovery than I&#39;d typically write. Rust really does guide you toward better architecture.</p> <p>Anyone else found Rust particularly well-suited for AI orchestration work? Curious about other async + AI patterns people are using.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Thin_Beat_9072"> /u/Thin_Beat_9072 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n211pj/built_my_first_rust_app_local_ai_orchestration/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n211pj/built_my_first_rust_app_local_ai_orchestration/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1zqpv/ownership_metaphor/" target="_blank">Ownership metaphor</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I recently tried to explained rust ownership system with the following analogy. </p> <p>What do you think about it? Is it clear? Is there something incorrect or misleading about it? </p> <p>You can think of ownership in Rust like the ownership of a painting: - I have a painting: <code>rust let painting:Painting = Painting::from(unpaid_artist); </code></p> <p>At the same time I can either 1. Ask a single painter to come work on my painting: <code>rust `fn paint(painting: &amp;mut Painting)` </code></p> <ol> <li>OR I can photocopy the painting in its current state for multiple people to look at it <code>rust fn look_at(photocopy: &amp;Painting) </code></li> </ol> <p>But I can&#39;t do both, because each painter needs the real painting to work on it and if they do, then the photocopies would not be up to date anymore.</p> <p>I can also sell/give the painting to someone else and give them full ownership of it, but then I cannot continue to use or change it like if it was still mine.</p> <p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=48ae7bc45cb8985eec45ab04b355fdcf">Example</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Bugibhub"> /u/Bugibhub </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1zqpv/ownership_metaphor/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1zqpv/ownership_metaphor/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1znfa/this_week_in_rust_614/" target="_blank">This Week in Rust #614</a>
            <div class="item-content">&#32; submitted by &#32; <a href="https://www.reddit.com/user/b-dillo"> /u/b-dillo </a> <br/> <span><a href="https://this-week-in-rust.org/blog/2025/08/27/this-week-in-rust-614/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1znfa/this_week_in_rust_614/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1uhfh/dioxus_hot_reloading_in_07_alpha_when_optional/" target="_blank">Dioxus Hot reloading in 0.7 alpha, when optional params change the page doesn't reload ...</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I use router with dioxus and in my page i have this <a href="http://127.0.0.1:8080/board/ffb544c7-0c1e-419c-960b-e0a608f60c26?list_uuid=&amp;task_uuid=">http://127.0.0.1:8080/board/ffb544c7-0c1e-419c-960b-e0a608f60c26?list_uuid=&amp;task_uuid=</a> where uuid can be another, but when i change it the page doesn&#39;t reload and i don&#39;t know why.</p> <p>Some help can be grateful.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Significant-Task-305"> /u/Significant-Task-305 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1uhfh/dioxus_hot_reloading_in_07_alpha_when_optional/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1uhfh/dioxus_hot_reloading_in_07_alpha_when_optional/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1t4g6/i_went_through_all_the_rfcs_and_tracking_issues/" target="_blank">I went through all the RFCs and Tracking Issues, here are the ones I'm most excited about</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Still RFCs that have not yet been accepted:</p> <ul> <li>Macro fragment fields <a href="https://github.com/rust-lang/rfcs/pull/3714">https://github.com/rust-lang/rfcs/pull/3714</a></li> <li><code>#[diagnostic::blocking]</code> <a href="https://github.com/rust-lang/rfcs/pull/3639">https://github.com/rust-lang/rfcs/pull/3639</a></li> <li>Named macro capture groups <a href="https://github.com/rust-lang/rfcs/pull/3649">https://github.com/rust-lang/rfcs/pull/3649</a></li> <li><code>#[cfg_alias]</code> <a href="https://github.com/rust-lang/rfcs/pull/3804">https://github.com/rust-lang/rfcs/pull/3804</a></li> <li>Tuple unpacking <a href="https://github.com/rust-lang/rfcs/pull/3723">https://github.com/rust-lang/rfcs/pull/3723</a></li> <li>Generic integers <a href="https://github.com/rust-lang/rfcs/pull/3686">https://github.com/rust-lang/rfcs/pull/3686</a></li> <li><code>#[derive(Default)]</code> on enum variants with fields <a href="https://github.com/rust-lang/rfcs/pull/3683">https://github.com/rust-lang/rfcs/pull/3683</a></li> <li>postfix <code>.match</code> <a href="https://github.com/rust-lang/rust/issues/121618">https://github.com/rust-lang/rust/issues/121618</a></li> <li>postfix <code>.macros!()</code> <a href="https://github.com/rust-lang/rfcs/pull/2442">https://github.com/rust-lang/rfcs/pull/2442</a></li> </ul> <p>Has tracking issues:</p> <ul> <li><code>become</code> (explicit tail calls) <a href="https://github.com/rust-lang/rust/issues/112788">https://github.com/rust-lang/rust/issues/112788</a></li> <li><code>cargo script</code> <a href="https://github.com/rust-lang/cargo/issues/12207">https://github.com/rust-lang/cargo/issues/12207</a></li> <li><code>core::mem::variant_count</code> <a href="https://github.com/rust-lang/rust/issues/73662">https://github.com/rust-lang/rust/issues/73662</a></li> <li>Deref patterns <a href="https://github.com/rust-lang/rust/issues/87121">https://github.com/rust-lang/rust/issues/87121</a></li> <li><code>cfg_select!</code> <a href="https://github.com/rust-lang/rust/issues/115585">https://github.com/rust-lang/rust/issues/115585</a></li> <li>Custom inner attributes <a href="https://github.com/rust-lang/rust/issues/54726">https://github.com/rust-lang/rust/issues/54726</a></li> <li><code>Iterator::intersperse</code> <a href="https://github.com/rust-lang/rust/issues/79524">https://github.com/rust-lang/rust/issues/79524</a></li> <li>Declarative macros 2.0 <a href="https://github.com/rust-lang/rust/issues/39412">https://github.com/rust-lang/rust/issues/39412</a></li> <li>Default field values <a href="https://github.com/rust-lang/rust/issues/132162">https://github.com/rust-lang/rust/issues/132162</a></li> <li>Delegation <a href="https://github.com/rust-lang/rust/issues/118212">https://github.com/rust-lang/rust/issues/118212</a></li> <li>Guard patterns <a href="https://github.com/rust-lang/rust/issues/129967">https://github.com/rust-lang/rust/issues/129967</a></li> <li><code>gen</code> blocks and functions <a href="https://github.com/rust-lang/rust/issues/117078">https://github.com/rust-lang/rust/issues/117078</a></li> <li><code>if let</code> guard <a href="https://github.com/rust-lang/rust/issues/51114">https://github.com/rust-lang/rust/issues/51114</a></li> <li>TAIT <a href="https://github.com/rust-lang/rust/issues/63063">https://github.com/rust-lang/rust/issues/63063</a></li> <li><code>!</code> <a href="https://github.com/rust-lang/rust/issues/35121">https://github.com/rust-lang/rust/issues/35121</a></li> <li><code>std::range</code> - New range type <a href="https://github.com/rust-lang/rust/issues/123741#issue-2236353974">https://github.com/rust-lang/rust/issues/123741#issue-2236353974</a></li> <li>Trait alias <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/trait-alias.html">https://doc.rust-lang.org/beta/unstable-book/language-features/trait-alias.html</a></li> <li><code>try</code> blocks <a href="https://github.com/rust-lang/rust/issues/31436">https://github.com/rust-lang/rust/issues/31436</a></li> <li>Macro meta-variable expressions <a href="https://github.com/rust-lang/rust/issues/83527">https://github.com/rust-lang/rust/issues/83527</a> <a href="https://github.com/rust-lang/rust/issues/124225">https://github.com/rust-lang/rust/issues/124225</a></li> <li><code>macro_rules!</code> derive macros <a href="https://github.com/rust-lang/rust/issues/143549">https://github.com/rust-lang/rust/issues/143549</a></li> <li><code>macro_rules!</code> attribute macros <a href="https://github.com/rust-lang/rust/issues/143547">https://github.com/rust-lang/rust/issues/143547</a></li> <li><code>Step</code> trait for <code>a..b</code> syntax overloading <a href="https://github.com/rust-lang/rust/issues/42168">https://github.com/rust-lang/rust/issues/42168</a></li> <li><code>hash_map!</code> macro <a href="https://github.com/rust-lang/rust/issues/144032">https://github.com/rust-lang/rust/issues/144032</a></li> </ul> <p>I would love if we got any 1 of those before chrismas, (maybe the <code>if let</code> guard :D)</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/nikitarevenco"> /u/nikitarevenco </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1t4g6/i_went_through_all_the_rfcs_and_tracking_issues/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1t4g6/i_went_through_all_the_rfcs_and_tracking_issues/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1t161/professional_rustaceans_whats_your_story/" target="_blank">Professional rustaceans, what's your story?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>That is, anyone who uses Rust in their job, how did you go about it? What is your background? Did you learn Rust separately and happen to find a job using it? Did you successfully introduce Rust into your current position?</p> <p>Long story short, I&#39;m curious in general but specifically I&#39;m a web app dev who is considering transitioning careers eventually, and I&#39;m definitely fascinated with Rust being a truly general purpose language, and just a general change of pace from my comfort zone of TypeScript. I didn&#39;t realize it essentially had FE WASM frameworks, so I figured it&#39;s <em>possible</em> I could at least shift my hobby projects to going down that route as I get more familiar with the language. I simply do not have a background in systems programming which seems to be where the biggest movement is happening. So, again, I&#39;m curious about absolutely anyone&#39;s professional experience, but I&#39;m also trying to figure out if there&#39;s any hope of transitioning in the near future, if it&#39;s more of a 5-10 year plan, or if I might as well ask a magic 8 ball.</p> <p>edit: typos</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/DuncSully"> /u/DuncSully </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1t161/professional_rustaceans_whats_your_story/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1t161/professional_rustaceans_whats_your_story/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1pjhm/pastepoint_secure_p2p_file_sharing_chat_built/" target="_blank">üöÄ PastePoint ‚Äì Secure P2P File Sharing & Chat Built with Rust</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hey folks üëã, I‚Äôve been working on <strong>PastePoint</strong>, an open-source project written in <strong>Rust (Actix-Web)</strong> for the backend and Angular for the frontend.</p> <p>üîë Key highlights:</p> <ul> <li>Built on <strong>Rust/Actix-Web</strong> for performance &amp; safety</li> <li>Peer-to-peer WebRTC file transfers (end-to-end encrypted via DTLS)</li> <li>Real-time messaging alongside file sharing</li> <li>Session-based model (no server-side file storage)</li> <li>Open source &amp; self-hostable: <a href="https://github.com/SloMR/pastepoint">PastePoint GitHub</a></li> </ul> <p>Would love feedback from the Rust community on the backend design, security model, and overall approach. üôè</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/xSloMSA"> /u/xSloMSA </a> <br/> <span><a href="https://pastepoint.com">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1pjhm/pastepoint_secure_p2p_file_sharing_chat_built/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1ndmg/linearizability_testing_s2dev_with_deterministic/" target="_blank">Linearizability testing s2.dev with deterministic simulation</a>
            <div class="item-content">&#32; submitted by &#32; <a href="https://www.reddit.com/user/Ok-List1527"> /u/Ok-List1527 </a> <br/> <span><a href="https://s2.dev/blog/linearizability">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1ndmg/linearizability_testing_s2dev_with_deterministic/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1m2nh/jane_street_rust_for_everyone/" target="_blank">Jane street - rust for everyone</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p><a href="https://youtu.be/R0dP-QR5wQo?si=9J1z5E1XQx2VTUSh">https://youtu.be/R0dP-QR5wQo?si=9J1z5E1XQx2VTUSh</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Krakenops744"> /u/Krakenops744 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1m2nh/jane_street_rust_for_everyone/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1m2nh/jane_street_rust_for_everyone/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1kplb/marco_a_lightweight_rust_markdown_composer/" target="_blank">Marco ‚Äî a lightweight Rust Markdown Composer</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>It is a GTK-based editor written in Rust. It&#39;s an experimental, extensible editor focused on structured editing, syntax-aware features, and custom markdown features.</p> <p><a href="https://preview.redd.it/8k5urmkg2llf1.png?width=838&amp;format=png&amp;auto=webp&amp;s=8ba14f980038ca63dec1eacbd9e6b5b55ccc067c">Work in progress</a></p> <p>Read more here: <a href="https://github.com/Ranrar/Marco">https://github.com/Ranrar/Marco</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/old-rust"> /u/old-rust </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1kplb/marco_a_lightweight_rust_markdown_composer/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1kplb/marco_a_lightweight_rust_markdown_composer/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1ick5/i_built_rust_bert_encoder/" target="_blank">I built Rust BERT encoder</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I needed vector embeddings in Rust, i was doing an offline RAG system in Rust, and was trying to minimize pulling in big runtimes or C/C++ dependencies.</p> <p>Someone mentioned ort, i got that to work but i thought that there was possibly a better solution.</p> <p>My use case was vector embeddings using <strong>all-MiniLM-L6-v2</strong>, getting the encode to work on ort took some time, execution providers, session providers, environment builders? - maybe this is to be expected of a full fledged ML inference engine.</p> <p>What i wanted</p> <pre><code>from sentence_transformers import SentenceTransformer model = SentenceTransformer(&#39;all-MiniLM-L6-v2&#39;) texts = [&quot;Hello world&quot;, &quot;How are you?&quot;] embeddings = model.encode(texts) </code></pre> <p>So i decided to ditch ort, and build a small library that can do inference.</p> <p>It now works, it&#39;s small and it produces correct embeddings.</p> <p>The code: </p> <pre><code>use edgebert::{Model, ModelType}; let model = Model::from_pretrained(ModelType::MiniLML6V2)?; let texts = vec![&quot;Hello world&quot;, &quot;How are you&quot;]; let embeddings = model.encode(texts.clone(), true)?; </code></pre> <p>Also, as it has minimal dependencies the side effect is that it is able to compile to WASM.</p> <pre><code>import init, { WasmModel, WasmModelType } from &#39;./pkg/edgebert.js&#39;; const model = WasmModel.from_type(WasmModelType.MiniLML6V2); const texts = [&quot;Hello world&quot;, &quot;How are you&quot;]; const embeddings = model.encode(texts, true); </code></pre> <p>I decided to create a GitHub repo for it if anyone sees any use for it or better yet, wants to contribute, it&#39;s not overwhelming and most of it happens in one file src/lib.rs</p> <p>Performance is slower than sentence-transformers on CPU. Makes sense - they&#39;ve had years of optimization. And i&#39;m not really competing with them on speed, it&#39;s more about simplicity and portability.</p> <p>But i think there are still obvious wins if anyone spots them. The softmax and layer norm implementations feel suboptimal.</p> <p>You can see the code here <a href="https://github.com/olafurjohannsson/edgebert">https://github.com/olafurjohannsson/edgebert</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/mr_potatohead_"> /u/mr_potatohead_ </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1ick5/i_built_rust_bert_encoder/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1ick5/i_built_rust_bert_encoder/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1hxjd/media_the_unexpected_productivity_boost_of_rust/" target="_blank">[Media] The unexpected productivity boost of Rust</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I have been working on a Rust and TypeScript codebase. And I have noticed that often I&#39;m reluctant to change the TypeScript stuff, because I&#39;m afraid of breaking something.</p> <p>This inspired me to write a blog post about the &quot;fear of change&quot; and the impact of Rust on my productivity. You can read it at the following link:</p> <p><a href="https://lubeno.dev/blog/rusts-productivity-curve">https://lubeno.dev/blog/rusts-productivity-curve</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/bkolobara"> /u/bkolobara </a> <br/> <span><a href="https://i.redd.it/rg4u6tmmjklf1.png">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1hxjd/media_the_unexpected_productivity_boost_of_rust/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1gnel/rustdoc_now_has_a_nightly_feature_to_allow_having/" target="_blank">Rustdoc now has a nightly feature to allow having macro expansion in source code pages</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>By enabling the <code>--generate-macro-expansion</code> on nightly rustdoc, you can now get &quot;expansion buttons&quot; in the source code pages to see what macro expanded code looks like. Don&#39;t hesitate to give it a try!</p> <p>PR: <a href="https://github.com/rust-lang/rust/pull/137229">https://github.com/rust-lang/rust/pull/137229</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/imperioland"> /u/imperioland </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1gnel/rustdoc_now_has_a_nightly_feature_to_allow_having/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1gnel/rustdoc_now_has_a_nightly_feature_to_allow_having/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1dxnh/announcing_tradingcalendar_a_comprehensive/" target="_blank">Announcing trading-calendar: A comprehensive trading calendar for global financial markets in Rust</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hey <a href="/r/rust">r/rust</a>!</p> <p>I&#39;m excited to share <strong>trading-calendar</strong>, a Rust crate I&#39;ve been working on that provides comprehensive trading calendar functionality for global financial markets. If you&#39;ve ever needed to check if markets are open, calculate trading days, or handle market holidays programmatically, this crate is for you!</p> <p>My goal was to create a reliable, performant library that handles all the complexity of global market calendars - from holiday adjustments to early closes to timezone management. Built with safety and performance in mind, it uses efficient LRU caching and is fully thread-safe.</p> <h2>Key Features</h2> <p>I&#39;ve tried to make it comprehensive yet simple to use:</p> <ul> <li><strong>Multiple Markets</strong>: NYSE, NASDAQ, LSE, TSE, TSX with accurate holiday calendars from 2020-2030</li> <li><strong>Trading Hours</strong>: Regular, pre-market, and after-hours sessions with automatic timezone handling<br/></li> <li><strong>Holiday Detection</strong>: All market holidays with proper weekend adjustments</li> <li><strong>Early Closes</strong>: Handles half-day schedules (Christmas Eve, Black Friday, etc.)</li> <li><strong>Performance</strong>: Efficient LRU caching with thread-safe concurrent access</li> <li><strong>Zero Dependencies</strong>: Only uses well-established crates like <code>chrono</code> and <code>chrono-tz</code></li> <li><strong>Proper Error Handling</strong>: Returns <code>Result</code> types with detailed error information</li> </ul> <h2>Quick Start</h2> <p>Getting started is simple. Here&#39;s how you can check if NYSE is open and get trading hours:</p> <p>```rust use trading_calendar::{TradingCalendar, Market};</p> <p>fn main() -&gt; trading_calendar::Result&lt;()&gt; { let nyse = TradingCalendar::new(Market::NYSE)?;</p> <pre><code>// Check if market is open if nyse.is_open_now()? { println!(&quot;NYSE is open for trading!&quot;); } // Get next market open let next_open = nyse.next_open()?; println!(&quot;NYSE opens: {}&quot;, next_open); // Check specific date let christmas = chrono::NaiveDate::from_ymd_opt(2025, 12, 25).unwrap(); if !nyse.is_trading_day(christmas)? { println!(&quot;Market closed on Christmas&quot;); } Ok(()) </code></pre> <p>} ```</p> <h2>Thread Safety Example</h2> <p>The calendar is thread-safe and can be shared across threads:</p> <p>```rust use std::sync::Arc; use trading_calendar::{TradingCalendar, Market};</p> <p>let calendar = Arc::new(TradingCalendar::new(Market::NYSE)?);</p> <p>// Share calendar across threads safely let cal_clone = Arc::clone(&amp;calendar); std::thread::spawn(move || { let is_open = cal_clone.is_open_now().unwrap_or(false); }); ```</p> <h2>What Makes This Different?</h2> <ul> <li><strong>Accuracy</strong>: Holiday calculations include all the edge cases - substitute holidays in Japan, Boxing Day adjustments in the UK, Canadian Victoria Day calculations, etc.</li> <li><strong>Performance</strong>: Holiday calculations are cached per year using LRU eviction</li> <li><strong>Safety</strong>: Proper error handling for unsupported years and invalid dates</li> <li><strong>Comprehensive Testing</strong>: Extensive test suite covering edge cases, DST transitions, and concurrent access</li> </ul> <h2>Links</h2> <p>The crate is open source and available now. I&#39;d love to hear your feedback, use cases, or bug reports!</p> <ul> <li><strong>Crates.io</strong>: <a href="https://crates.io/crates/trading-calendar">https://crates.io/crates/trading-calendar</a></li> <li><strong>GitHub</strong>: <a href="https://github.com/danjloveless/trading-calendar">https://github.com/danjloveless/trading-calendar</a><br/></li> <li><strong>Docs.rs</strong>: <a href="https://docs.rs/trading-calendar">https://docs.rs/trading-calendar</a></li> </ul> <p>The crate is dual-licensed under MIT/Apache-2.0. PRs welcome - especially if you want to add support for more markets!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Afraid_Relief_3720"> /u/Afraid_Relief_3720 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1dxnh/announcing_tradingcalendar_a_comprehensive/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1dxnh/announcing_tradingcalendar_a_comprehensive/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n1byz5/threeway_merge_100_gitcompatible_3way_string/" target="_blank">threeway_merge - 100% Git-compatible 3-way string merging in Rust</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>So I was working on a project that needed to merge text changes (think collaborative editing), and I needed something that worked exactly like <code>git merge-file</code> but for strings in memory.</p> <p>Looked around and the existing options were either:</p> <ul> <li>Required writing to temp files (I wanted to work directly with strings)</li> <li>Didn&#39;t handle conflicts the same way Git does</li> <li>Missing some of the merge strategies I wanted</li> </ul> <p>So I ended up wrapping libgit2&#39;s xdiff library (the same C code Git uses) with Rust bindings.</p> <p><code>rust use threeway_merge::{merge_strings, MergeOptions}; let result = merge_strings(base, ours, theirs, &amp;MergeOptions::default())?; </code></p> <p>It supports all Git merge algorithms (Myers, Patience, Histogram, etc.) and conflict styles (normal, diff3, zdiff3). You can also favor one side automatically or combine changes with the union strategy.</p> <p>I wrote tests that run <code>git merge-file</code> and compare outputs feature by feature, and my crate passes 100% of them.</p> <p>Anyway, figured others might need this too so I put it on crates.io: <a href="https://crates.io/crates/threeway_merge">https://crates.io/crates/threeway_merge</a></p> <p>Code&#39;s here if anyone&#39;s curious about the implementation: <a href="https://github.com/levish0/threeway-merge-rs">https://github.com/levish0/threeway-merge-rs</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/shiueo"> /u/shiueo </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n1byz5/threeway_merge_100_gitcompatible_3way_string/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n1byz5/threeway_merge_100_gitcompatible_3way_string/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n193zy/cargopup_archunitstyle_linting_for_rust/" target="_blank">Cargo-pup ‚Äì ArchUnit-style linting for rust</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hey reddit! I‚Äôve been working on <a href="https://github.com/DataDog/cargo-pup">cargo-pup</a>, a Rust tool for defining and enforcing architectural rules in your codebase - like <a href="https://www.archunit.org/">ArchUnit</a> for Java, or Clippy, but for project-specific architecture constraints rather than linting. It lets you write architectural assertions in Rust using a builder-style API. For example</p> <ul> <li>Enforce layering: &quot;REST modules shouldn‚Äôt use SQL clients&quot;</li> <li>Enforce consistency: &quot;Types implementing MyTrait must be named MyTrait and live in Impl* modules&quot;</li> </ul> <p>There are more examples in the <a href="https://github.com/DataDog/cargo-pup/blob/main/test_app/tests/pup_ron_test.rs">included sample app</a>, and the <a href="https://github.com/DataDog/cargo-pup/blob/main/tests/ron_test.rs">cargo-pup tests for cargo-pup itself</a>. </p> <p>Pup emits regular rustc lints (just like Clippy or cargo check) and runs either as a test or via a `cargo pup` CLI, the latter of which you can drop into your CI. This is very early days! I work at Datadog, but this isn‚Äôt an official project ‚Äî just something I built to explore what architectural linting might look like in Rust, and to scratch my own itch :)Would love any feedback or questions!</p> <p>Scott</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Foshhh"> /u/Foshhh </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n193zy/cargopup_archunitstyle_linting_for_rust/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n193zy/cargopup_archunitstyle_linting_for_rust/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1n18kpm/multiple_mutable_borrows_allowed/" target="_blank">Multiple mutable borrows allowed?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Im trying to understand the borrow checker, and i&#39;m struggling with &quot;multiple mutable borrow&quot; scenarios. </p> <p>looking at the below code, I am able to borrow the original variable mutiple times as mutable and immutable. In fact, I can even pass the same variable as mutable to function as a reference multiple times as well. </p> <p><code>fn main() {</code></p> <p><code>let mut original = String::from(&quot;hi&quot;);</code></p> <p><code>let copy_1 = &amp;mut original;</code></p> <p><code>let copy_2 = &amp;original;</code></p> <p><code>modify(&amp;mut original);</code></p> <p><code>modify(&amp;mut original);</code></p> <p><code>dont_modify(&amp;original);</code></p> <p><code>}</code></p> <p><code>fn modify(mut s: &amp;mut String) { }</code></p> <p><code>fn dont_modify(s: &amp;String) { }</code></p> <p>why does this not throw a borrow checker compiler error? </p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/eleon182"> /u/eleon182 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1n18kpm/multiple_mutable_borrows_allowed/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1n18kpm/multiple_mutable_borrows_allowed/">[comments]</a></span></div>
          </li>
  
        </ul>
  
        <h3 class="subreddit">r/golang</h3>
        <ul class="item-list">
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1zfps/is_creating_too_many_contexts_a_bad_practice/" target="_blank">Is creating too many contexts a bad practice?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hi, I&#39;m using NATS messaging service in my code and my consumer runs on a schedule. When the scheduler window is up, my consumer workers(go routines) exit abrupting without gracefully handling the existing in-flight messages as the context gets cancelled due to the scheduler timeup. To fix this, I create a new context with a timeout for every message, so that even when the parent contect gets cancelled the workers have some time to finish their processing. I got the feedback that creating a new context per message is not a good idea especially when processing billions of messages. When I checked online, I learnt that creating context per message is idiomatic go practice. Please throw some light on this. </p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Jalsa31"> /u/Jalsa31 </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1zfps/is_creating_too_many_contexts_a_bad_practice/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1zfps/is_creating_too_many_contexts_a_bad_practice/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1r26y/we_built_it_then_we_freed_it_telemetry_harbor/" target="_blank">We Built It, Then We Freed It: Telemetry Harbor Goes Open Source</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/golang/comments/1n1r26y/we_built_it_then_we_freed_it_telemetry_harbor/">  </a> </td><td> <!-- SC_OFF --><div class="md"><p>Couple weeks ago, we published our story about rewriting our entire ingest pipeline from Python to Go, achieving a 10x performance improvement and eliminating the crashes that plagued our early system. The response was incredible developers loved the technical deep-dive, and many asked to try Telemetry Harbor for their projects. Today we wanted to follow up with this little post.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/squadfi"> /u/squadfi </a> <br/> <span><a href="https://telemetryharbor.com/blog/we-built-it-then-we-freed-it-telemetry-harbor-goes-open-source/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1r26y/we_built_it_then_we_freed_it_telemetry_harbor/">[comments]</a></span> </td></tr></table></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1psjb/go_struct_alignment_a_practical_guide/" target="_blank">Go Struct Alignment: a Practical Guide</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/golang/comments/1n1psjb/go_struct_alignment_a_practical_guide/">  </a> </td><td> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Real_Blank"> /u/Real_Blank </a> <br/> <span><a href="https://medium.com/@Realblank/go-struct-alignment-a-practical-guide-e725c8e1d14e">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1psjb/go_struct_alignment_a_practical_guide/">[comments]</a></span> </td></tr></table></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1mse3/building_a_task_queueing_system_need_some/" target="_blank">Building a task queueing system - need some directions and feedback.</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hey guys,</p> <p>I&#39;m building a distributed task queueing system in golang, I&#39;m doing this to learn the language, but I do want to build something meaningful and useable. (maybe even an OSS if its anything worthwhile lol)</p> <p>Without going too verbose, the system I built currently works like this -</p> <p>Dispatcher : It has multiple queues (with configurable priorities) that you can send requests to. The dispatcher holds the request in an in-memory channel &amp; map. (This is just a v1, for low request counts, I do plan on extending this for redis / SQS later on)</p> <p>Currently, the worker I intend to build has two modes - http/CLI &amp; in-situ. The workers will be able to take a maximum of &quot;N&quot; jobs - configured by the user.</p> <p>HTTP is pretty self-explanatory - pinging the dispatcher to get a job, and it can either be linked to run a CLI command or forward the request to a port or spawn a command.</p> <p>in-situ is not something I thought of before, but I suppose it would be a function call instead of http + ping.</p> <p>Oh and there&#39;s an optional ACK on receive/completion configurable by the user - so that the jobs can permanently exit the memory.</p> <p>I know that this might be unnecessary, and complex, and Kafka + some sort of queue can pretty much replace this system reliably, but I want to learn and build scalable systems.</p> <p>With that in mind, I need some guidance for the following:</p> <ol> <li>Logging : I initially just setup an sqlite instance and put everything in there, but I&#39;ve since updated it to be a file based system. The current setup i have is a configurable size + cron based setup - the users can store the logs in a common file, that creates a new file if a size limit is breached, or if a cron job asks a new log file to be created.</li> </ol> <p>I plan to have an endpoint which would stream the files based on users requirement so they can do whatever they want with it - and currently the fields I have are:</p> <p><code>job_id, priority, payload, arrival_time, dispatch_time, ack_time, ack_worker_id, status, log</code></p> <p>This is naive, but is there anything else I could log or modify in the logging system entirely to use some third party logging libraries?</p> <ol> <li><p>What other features do I need for this task queuing system at minimum? I see retries being an important feature - backoff, time based etc. I also consider persistence &amp; recovery (but with my file based logging &amp; channel based queueing it&#39;s not really efficient i suppose) I also considered security with auth etc</p></li> <li><p>I currently use WRR + carry to cycle between the queues. I looked at Deficit round robin, but that&#39;s a case for different job sizes. Is there anything else that&#39;s more suited for this task?</p></li> </ol> <p>Please feel free to leave any criticisms or feedback, I&#39;d love to learn and improve this system!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/malak_hassan"> /u/malak_hassan </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1mse3/building_a_task_queueing_system_need_some/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1mse3/building_a_task_queueing_system_need_some/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1m2i6/goutcp_universal_tool_calling_protocol/" target="_blank">go-utcp. Universal Tool Calling Protocol</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hey <a href="/r/golang">r/golang</a></p> <p>I&#39;m creator of the official Go implementation of UTCP (Universal Tool Calling Protocol), and I gotta say‚Äîit‚Äôs pretty cool. The repo‚Äôs chock-full of features:</p> <p>Multiple built‚Äëin transports: HTTP, WebSockets, TCP/UDP, gRPC, GraphQL, CLI, streaming, Server‚ÄëSent Events, WebRTC, even MCP. Basically, whatever your tool‚Äëcalling setup, it‚Äôs probably already supported. </p> <p>Handy utilities like an OpenApiConverter to turn OpenAPI definitions into UTCP manuals. </p> <p>Getting started is straightforward: go get github.com/universal-tool-calling-protocol/go-utcp@latest and you&#39;re good to go. The examples in the repo are also super helpful for seeing it in action. </p> <p>Also cool: as of August 19, 2025, the latest release is v1.7.0‚Äîso it&#39;s being actively maintained. </p> <p>If you&#39;re building anything that needs a versatile, transport-agnostic way to call tools or services in Go, give it a shot!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Revolutionary_Sir140"> /u/Revolutionary_Sir140 </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1m2i6/goutcp_universal_tool_calling_protocol/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1m2i6/goutcp_universal_tool_calling_protocol/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1l50a/preserving_order_in_concurrent_go_3_approaches/" target="_blank">Preserving Order in Concurrent Go: 3 Approaches Compared</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/golang/comments/1n1l50a/preserving_order_in_concurrent_go_3_approaches/">  </a> </td><td> &#32; submitted by &#32; <a href="https://www.reddit.com/user/destel116"> /u/destel116 </a> <br/> <span><a href="https://destel.dev/blog/preserving-order-in-concurrent-go">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1l50a/preserving_order_in_concurrent_go_3_approaches/">[comments]</a></span> </td></tr></table></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1ku56/for_those_of_us_who_have_to_use_js_sometimes_how/" target="_blank">For those of us who have to use JS sometimes, how do you stay sane?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I&#39;ve had to work with JS here and there, and it honestly puts me into a horrible mood. I don&#39;t stay up to date on frameworks in JS, so I&#39;m using either commonJS or ES, and I just wonder if they purposely make it hard to do stuff? It&#39;s really unbelievable how brutal the developer experience can be unless you are proactively making tools or testing 3rd party tools for help. </p> <p>Dependency management is even wilder. There are at least 3 maybe 4 dependency managers to choose from, and to top it off you can&#39;t even run the latest Node versions on some OS&#39; due to glibc incompatibilities(kind of ironic). Another complaint is that even ES6 and common JS can&#39;t be interchanged in the same module, effectively making it two languages. I can&#39;t explain why Go isn&#39;t <em>more</em> popular, but I honestly can&#39;t even fathom the justification for how JS <em>is popular</em>. It&#39;s developing on hard-mode by default. Maybe I&#39;m just spoiled by Go. What are your thoughts?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/workmakesmegrumpy"> /u/workmakesmegrumpy </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1ku56/for_those_of_us_who_have_to_use_js_sometimes_how/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1ku56/for_those_of_us_who_have_to_use_js_sometimes_how/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1ia4r/just_released_goqueue_v021/" target="_blank">Just released GoQueue v0.2.1</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>For developers working on Go applications requiring dependable background job processing, </p> <p>GoQueue is your go-to solution. This library offers versatile database driver compatibility, supporting PostgreSQL, MySQL, Redis, AWS SQS, and even in-memory storage. With GoQueue, you get a unified API experience and a range of robust features suitable for production environments. </p> <p>Benefit from functionalities like automated retries, dead letter queues, and seamless middleware integration. </p> <p>Say goodbye to juggling multiple queue systems across projects - GoQueue simplifies your workflow with its comprehensive capabilities.</p> <p><a href="https://github.com/saravanasai/goqueue">https://github.com/saravanasai/goqueue</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/saravanasai1412"> /u/saravanasai1412 </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1ia4r/just_released_goqueue_v021/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1ia4r/just_released_goqueue_v021/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1i81o/how_strongly_should_i_adhere_to_never_return/" target="_blank">How strongly should I adhere to "never return interfaces"?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Let&#39;s say I&#39;m trying to load and display a data structure in a well-defined type hierarchy, but one which I won&#39;t know until runtime. For example, I want to load and display data about an Animal on the screen, but I won&#39;t know what animal I&#39;ve loaded data for until I deserialize the data for that Animal at runtime. What would be the idiomatic way to do this in Go?</p> <p>In most other languages I might have a <code>load</code> function that returns a generic Animal interface or a Animal base type, and then maybe a <code>display(a: Animal)</code> function with a switch statement on which type of Animal it is, or else a <code>display()</code> function on the base Animal type/interface that I can just invoke with the generic Animal I&#39;ve retrieved from <code>load</code>.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Important-Bit4540"> /u/Important-Bit4540 </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1i81o/how_strongly_should_i_adhere_to_never_return/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1i81o/how_strongly_should_i_adhere_to_never_return/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1gfjr/exploiting_zero_values_in_maps/" target="_blank">Exploiting Zero Values in Maps</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p><a href="https://github.com/go-monk/exploiting-zero-values-in-maps">https://github.com/go-monk/exploiting-zero-values-in-maps</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/reisinge"> /u/reisinge </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1gfjr/exploiting_zero_values_in_maps/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1gfjr/exploiting_zero_values_in_maps/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1fok1/anyone_worked_on_upgrading_multiple_go_services/" target="_blank">Anyone worked on upgrading multiple Go services?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hi everyone,</p> <p>The current org I work at has about 50 microservices which use different versions of Go varying from v1.11 - v1.23.1. I am currently working on upgrading and bringing all of them to version v1.23.12</p> <p>Well Go&#39;s backward compatibility saves a lot here but are there any specific issues that you folks have faced or solved this problem earlier? My plan is to upgrade them in 3 phases </p> <ul> <li><strong>Phase 1: Libraries and Shared Components</strong> <ul> <li>skips grpc contracts</li> <li>upgrade of protobuf versions might take longer</li> </ul></li> <li><strong>Phase 2: Libraries and Shared Components</strong> <ul> <li>includes grpc contracts</li> </ul></li> <li><strong>Phase 3: Core Business Services</strong> <ul> <li>higher business critical services</li> </ul></li> </ul> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/The-Ball-23"> /u/The-Ball-23 </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1fok1/anyone_worked_on_upgrading_multiple_go_services/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1fok1/anyone_worked_on_upgrading_multiple_go_services/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1evl7/using_go_based_cshared_library_in_net/" target="_blank">Using Go based c-shared library in .NET</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I have a library that I&#39;ve developed in Go that implements some asynchronous networking stuff that is beyond the scope of this post.</p> <p>I&#39;ve successfully used this library in some C, C++ and Python code but I&#39;m now struggling to get this to work in .NET on Linux.</p> <p>The library seems to work fine at first but after it runs for some time the application, it is used by, runs into a segmentation fault.</p> <p>Since that, I&#39;ve <a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/abi-support#golang">learned that using in-process Go code will not work in .NET</a> as, currently, <a href="https://github.com/dotnet/runtime/issues/110368">.NET does not register all signal handlers using <code>SA_ONSTACK</code></a>.</p> <p>I&#39;m now looking for alternatives. I&#39;ve already implemented an application that exposes the library&#39;s API as a gRPC interface and that works fine but feels a bit clunky as the library is intended to be used 1:1 and, at least in theory, the gRPC interface can be called by multiple applications simultaneously. Also I&#39;ve not found an elegant way to register function callbacks that allow the Go code to call a function on the application side. I&#39;m currently looking at <a href="https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc">bidirectional streams</a> to allow that pattern but, once again, that feels a bit clunky.</p> <p>Are there other alternatives that you guys suggest I should look into?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/ee1c0"> /u/ee1c0 </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1evl7/using_go_based_cshared_library_in_net/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1evl7/using_go_based_cshared_library_in_net/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1b58h/analytics_for_cli_apps/" target="_blank">Analytics for CLI apps?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hey everyone!</p> <p>Do you build a CLI for work or your open-source project? Do you have analytics set up to track usage?</p> <p>I&#39;ve written a few CLIs, and I want to know:</p> <ul> <li>Which commands and flags are used most often?</li> <li>Which platforms is the CLI being installed &amp; run on?</li> <li>The most common user errors - domain errors like auth, validation, and not code exceptions (though those would be good to know too!).</li> </ul> <p>I&#39;ve not found any open-source or hosted services offering CLI analytics, and I&#39;m very curious to hear if this is just not a thing. Any recommendations for Go SDKs, blog posts, or pointers on how to think about this are appreciated!</p> <p>(PS: I am asking a question, not stealing your data, so why the downvotes? I&#39;d really love to understand what is wrong with the question to merit them).</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/finallybeing"> /u/finallybeing </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1b58h/analytics_for_cli_apps/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1b58h/analytics_for_cli_apps/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1ai9p/build_ai_systems_in_pure_go_production_llm_course/" target="_blank">Build AI Systems in Pure Go, Production LLM Course</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/golang/comments/1n1ai9p/build_ai_systems_in_pure_go_production_llm_course/">  </a> </td><td> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Historical_Wing_9573"> /u/Historical_Wing_9573 </a> <br/> <span><a href="https://vitaliihonchar.com/courses/production-llm-systems-with-go">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1ai9p/build_ai_systems_in_pure_go_production_llm_course/">[comments]</a></span> </td></tr></table></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1n1aamu/whats_the_best_practice_to_store_config/" target="_blank">What's the best practice to store config?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hello all,</p> <p>My golang project uses viper for non-sensitive config and godotenv for sensitive config. </p> <p>In production in AWS, I&#39;m planning to use AWS Parameter Store for non-sensitive config and AWS Secrets Manager for sensitive config. </p> <p>However, since non-sensitive config are just plain text values, I think I can save that in a dynamodb table like projectname_parameter_store. </p> <p>So my new plan looks like, use dynamodb projectname_parameter_store table for non-sensitive config. And use real AWS Parameter Store for sensitive .env config since Parameter Store is secure and cheap while compared to AWS Secrets Manager. </p> <p>I&#39;m building a scalable ECS Fargate tasks and managing config.yaml and .env file in each task doesn&#39;t sound like the standard practice. So DynamoDB/Parameter Store/Secrets Manager is preferred over config.yaml or .env files</p> <p>Planning to use cache TTL of 1 hour. So won&#39;t be hitting DynamoDB/Parameter Store/Secrets Manager for each request. </p> <p>Am I in the right direction? </p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/apidevguy"> /u/apidevguy </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1n1aamu/whats_the_best_practice_to_store_config/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1n1aamu/whats_the_best_practice_to_store_config/">[comments]</a></span></div>
          </li>
  
        </ul>
  
        <h3 class="subreddit">r/rust_gamedev</h3>
        <ul class="item-list">
  
          <li>
            <a href="https://www.reddit.com/r/rust_gamedev/comments/1n1pook/after_a_lot_of_late_night_jumps_parachute_clicker/" target="_blank">After a lot of late night jumps, Parachute Clicker is finally in BETA! Build with bevy and rust.</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/rust_gamedev/comments/1n1pook/after_a_lot_of_late_night_jumps_parachute_clicker/">  </a> </td><td> <!-- SC_OFF --><div class="md"><p>Thanks for testing! Your feedback helps shape the game.<br/> Made with <strong>Bevy, Rust, egui, and bevy_hanabi.</strong></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Big_Membership9737"> /u/Big_Membership9737 </a> <br/> <span><a href="https://meapps.itch.io/parachuteclicker">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust_gamedev/comments/1n1pook/after_a_lot_of_late_night_jumps_parachute_clicker/">[comments]</a></span> </td></tr></table></div>
          </li>
  
        </ul>
  
      </div>
  
    </div>
  </body>
  </html>