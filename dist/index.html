
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      :root {
        --bg-color: #121212;
        --container-bg: #1e1e1e;
        --text-color: #e0e0e0;
        --heading-color: #ffffff;
        --subheading-color: #58a6ff;
        --link-color: #58a6ff;
        --border-color: #333333;
        --item-hover: #2a2a2a;
        --shadow: 0 4px 12px rgba(0,0,0,0.2);
        --accent-color: #58a6ff;
        --tooltip-bg: #2a2a2a;
        --tooltip-text: #e0e0e0;
        --table-header-bg: #2a2a2a;
        --table-header-text: #ffffff;
        --table-row-odd: #1e1e1e;
        --table-row-even: #252525;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        line-height: 1.5;
        color: var(--text-color);
        background-color: var(--bg-color);
        margin: 0;
        padding: 0;
      }
      
      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 15px;
      }
      
      .card {
        background-color: var(--container-bg);
        border-radius: 8px;
        box-shadow: var(--shadow);
        padding: 16px;
        margin-bottom: 16px;
        transition: all 0.2s ease;
      }
      
      .card:hover {
        box-shadow: 0 6px 12px rgba(0,0,0,0.15);
      }

      .header-p {
        margin: 0.2em 0;
        font-weight: 500;
        letter-spacing: -0.02em;
        font-size: 14px;
      }

      .subreddit {
        text-align: right;
      }
      
      h2 {
        font-size: 18px;
        font-weight: 600;
        color: var(--heading-color);
        margin-top: 0;
        margin-bottom: 12px;
        padding-bottom: 6px;
        border-bottom: 2px solid var(--accent-color);
      }
      
      h3 {
        font-size: 16px;
        font-weight: 500;
        color: var(--subheading-color);
        margin-bottom: 8px;
      }
      
      a {
        color: var(--link-color);
        text-decoration: none;
        transition: color 0.2s ease;
      }
      
      a:hover {
        color: var(--accent-color);
        text-decoration: underline;
      }
      
      /* Weather Table Styles */
      .weather-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        border-radius: 6px;
        overflow: hidden;
      }
      
      .weather-table th {
        background-color: var(--table-header-bg);
        color: var(--table-header-text);
        font-weight: 500;
        text-align: left;
        padding: 8px 12px;
        font-size: 14px;
      }
      
      .weather-table td {
        padding: 8px 12px;
        border-bottom: 1px solid var(--border-color);
        font-size: 14px;
      }
      
      .weather-table tr:nth-child(odd) {
        background-color: var(--table-row-odd);
      }
      
      .weather-table tr:nth-child(even) {
        background-color: var(--table-row-even);
      }
      
      .weather-table tr:last-child td {
        border-bottom: none;
      }
      
      .comic {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 12px 0;
      }
      
      .comic-title {
        font-weight: 600;
        margin-bottom: 8px;
        text-align: center;
        font-size: 15px;
      }
      
      .comic img {
        max-width: 600px;
        max-height: auto;
        object-fit: contain;
        border-radius: 6px;
        margin-bottom: 6px;
        cursor: pointer;
      }
      
      .comic-number {
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.7;
        margin-top: 3px;
      }
      
      .item-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      
      .item-list li {
        padding: 8px 10px;
        border-bottom: 1px solid var(--border-color);
        position: relative;
        font-size: 14px;
      }
      
      .item-list li:last-child {
        border-bottom: none;
      }
      
      .item-list li:hover {
        background-color: var(--item-hover);
        border-radius: 4px;
      }
      
      .item-content {
        display: none;
        position: absolute;
        z-index: 10;
        background-color: var(--tooltip-bg);
        color: var(--tooltip-text);
        border-radius: 6px;
        padding: 15px;
        width: 90%;
        max-width: 100%;
        box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        left: 50%;
        transform: translateX(-50%);
        bottom: 100%;
        font-size: 13px;
        line-height: 1.4;
        overflow: auto;
        max-height: 250px;
        border: 4px solid var(--border-color);
      }

      .item-content::-webkit-scrollbar {
        display: none;
      }

      .item-list li:hover .item-content {
        display: block;
      }
      
      .item-list li::before {
        content: "‚Ä¢";
        color: var(--accent-color);
        font-weight: bold;
        display: inline-block;
        width: 1em;
        margin-left: -0.5em;
      }
      
      @media (max-width: 600px) {
        .container {
          padding: 10px;
        }
        
        .card {
          padding: 12px;
          margin-bottom: 12px;
        }
        
        .item-content {
          width: 95%;
          left: 2.5%;
          transform: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
  
      <div class="card">
        <h2>Huginn Daily</h2>
        <p class="header-p">Monday, February 16, 2026</p>
        <p class="header-p">ecf71acb-fa16-4655-a27f-cdcbc3c916cc</p>
      </div>
  
      <div class="card">
        <h2>Weather</h2>
        <table class="weather-table">
          <tr>
            <th>Summary</th>
            <td>‚õÖÔ∏è Mostly cloudy starting in the evening.</td>
          </tr>
          <tr>
            <th>Temperature Range</th>
            <td>12¬∞C to 21¬∞C (53¬∞F to 70¬∞F)</td>
          </tr>
          <tr>
            <th>Feels Like</th>
            <td>Low: 46¬∞F | High: 70¬∞F</td>
          </tr>
          <tr>
            <th>Humidity</th>
            <td>69%</td>
          </tr>
          <tr>
            <th>Wind</th>
            <td>14 km/h (9 mph), Direction: 44¬∞</td>
          </tr>
          <tr>
            <th>Precipitation</th>
            <td>Probability: 0%, Type: No precipitation expected</td>
          </tr>
          <tr>
            <th>Sunrise / Sunset</th>
            <td>üåÖ 06:32 AM / üåá 05:31 PM</td>
          </tr>
          <tr>
            <th>Moon Phase</th>
            <td>Waning Crescent (97%)</td>
          </tr>
          <tr>
            <th>Cloud Cover</th>
            <td>65%</td>
          </tr>
          <tr>
            <th>Pressure</th>
            <td>1015.43 hPa</td>
          </tr>
          <tr>
            <th>Dew Point</th>
            <td>49.79¬∞F</td>
          </tr>
          <tr>
            <th>Visibility</th>
            <td>5.95 miles</td>
          </tr>
        </table>
      </div>
  
      <div class="card">
        <h2>Other</h2>
        <ul class="item-list">
  
          <li>
            <a href="https://selfh.st/weekly/2026-02-13/" target="_blank"> Self-Host Weekly (13 February 2026) </a>
            <div class="item-content">
			  Become a <a href="https://selfh.st/membership">paid subscriber</a> to access the newsletter‚Äôs full-text RSS feed or <a href="https://selfh.st">continue reading on selfh.st</a>.
		  </div>
          </li>
  
        </ul>
      </div>
  
      <div class="card">
        <h2>Golang</h2>
        <ul class="item-list">
  
          <li>
            <a href="https://go.dev/blog/testing-time" target="_blank">Testing Time (and other asynchronicities)</a>
            <div class="item-content">
<div id="blog"><div id="content">
  <div id="content">

    <div class="Article" data-slug="/blog/testing-time">
    
    <h1 class="small"><a href="/blog/">The Go Blog</a></h1>
    

    <h1>Testing Time (and other asynchronicities)</h1>
      
      <p class="author">
      Damien Neil<br>
      26 August 2025
      </p>
      
      <div class='markdown'>
<p>In Go 1.24, we introduced the <a href="/pkg/testing/synctest"><code>testing/synctest</code></a>
package as an experimental package.
This package can significantly simplify writing tests for concurrent,
asynchronous code.
In Go 1.25, the <code>testing/synctest</code> package has graduated from experiment
to general availability.</p>
<p>What follows is the blog version of my talk on
the <a href="/pkg/testing/synctest"><code>testing/synctest</code></a> package
at GopherCon Europe 2025 in Berlin.</p>
<h2 id="what-is-an-asynchronous-function">What is an asynchronous function?</h2>
<p>A synchronous function is pretty simple.
You call it, it does something, and it returns.</p>
<p>An asynchronous function is different.
You call it, it returns, and then it does something.</p>
<p>As a concrete, if somewhat artificial, example,
the following <code>Cleanup</code> function is synchronous.
You call it, it deletes a cache directory, and it returns.</p>
<pre><code>func (c *Cache) Cleanup() {
    os.RemoveAll(c.cacheDir)
}
</code></pre>
<p><code>CleanupInBackground</code> is an asynchronous function.
You call it, it returns, and the cache directory is deleted&hellip;sooner or later.</p>
<pre><code>func (c *Cache) CleanupInBackground() {
    go os.RemoveAll(c.cacheDir)
}
</code></pre>
<p>Sometimes an asynchronous function does something in the future.
For example, the <code>context</code> package&rsquo;s <code>WithDeadline</code> function
returns a context which will be canceled in the future.</p>
<pre><code>package context

// WithDeadline returns a derived context
// with a deadline no later than d.
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
</code></pre>
<p>When I talk about testing concurrent code,
I mean testing these sorts of asynchronous operations,
both ones which use real time and ones which do not.</p>
<h2 id="tests">Tests</h2>
<p>A test verifies that a system behaves as we expect.
There&rsquo;s a lot of terminology describing types
of test&ndash;unit tests, integration tests, and so on&ndash;but
for our purposes here every kind of test reduces to three steps:</p>
<ol>
<li>Set up some initial conditions.</li>
<li>Tell the system under test to do something.</li>
<li>Verify the result.</li>
</ol>
<p>Testing a synchronous function is straightforward:</p>
<ul>
<li>You call the function;</li>
<li>the function does something and returns;</li>
<li>you verify the result.</li>
</ul>
<p>Testing an asynchronous function, however, is tricky:</p>
<ul>
<li>You call the function;</li>
<li>it returns;</li>
<li>you wait for it to finish doing whatever it does;</li>
<li>you verify the result.</li>
</ul>
<p>If you don&rsquo;t wait for the correct amount of time,
you may find yourself verifying the result of an operation that hasn&rsquo;t happened yet
or has only happened partially.
This never ends well.</p>
<p>Testing an asynchronous function is especially tricky
when you want to assert that something has <em>not</em> happened.
You can verify that the thing has not happened yet,
but how do you know with certainty that it isn&rsquo;t going to happen later?</p>
<h2 id="an-example">An example</h2>
<p>To make things a little more concrete,
let&rsquo;s work with a real-world example.
Consider the <code>context</code> package&rsquo;s <code>WithDeadline</code> function again.</p>
<pre><code>package context

// WithDeadline returns a derived context
// with a deadline no later than d.
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
</code></pre>
<p>There are two obvious tests to write for <code>WithDeadline</code>.</p>
<ol>
<li>The context is <em>not</em> canceled <em>before</em> the deadline.</li>
<li>The context <em>is</em> canceled <em>after</em> the deadline.</li>
</ol>
<p>Let&rsquo;s write a test.</p>
<p>To keep the amount of code marginally less overwhelming,
we&rsquo;ll just test the second case:
After the deadline expires, the context is canceled.</p>
<pre><code>func TestWithDeadlineAfterDeadline(t *testing.T) {
    deadline := time.Now().Add(1 * time.Second)
    ctx, _ := context.WithDeadline(t.Context(), deadline)

    time.Sleep(time.Until(deadline))

    if err := ctx.Err(); err != context.DeadlineExceeded {
        t.Fatalf(&quot;context not canceled after deadline&quot;)
    }
}
</code></pre>
<p>This test is simple:</p>
<ol>
<li>Use <code>context.WithDeadline</code> to create a context with a deadline one second in the future.</li>
<li>Wait until the deadline.</li>
<li>Verify that the context is canceled.</li>
</ol>
<p>Unfortunately, this test obviously has a problem.
It sleeps until the exact moment the deadline expires.
Odds are good that the context has not been canceled yet by the time we examine it.
At best, this test will be very flaky.</p>
<p>Let&rsquo;s fix it.</p>
<pre><code>time.Sleep(time.Until(deadline) + 100*time.Millisecond)
</code></pre>
<p>We can sleep until 100ms after the deadline.
A hundred milliseconds is an eternity in computer terms.
This should be fine.</p>
<p>Unfortunately, we still have two problems.</p>
<p>First, this test takes 1.1 seconds to execute.
That&rsquo;s slow.
This is a simple test.
It should execute in milliseconds at the most.</p>
<p>Second, this test is flaky.
A hundred milliseconds is an eternity in computer terms,
but on an overloaded continuous integration (CI) system
it isn&rsquo;t unusual to see pauses much longer than that.
This test will probably pass consistently on a developer&rsquo;s workstation,
but I would expect occasional failures in a CI system.</p>
<h2 id="slow-or-flaky-pick-two">Slow or flaky: Pick two</h2>
<p>Tests that use real time are always slow or flaky.
Usually they&rsquo;re both.
If the test waits longer than necessary, it is slow.
If it doesn&rsquo;t wait long enough, it is flaky.
You can make the test more slow and less flaky,
or less slow and more flaky,
but you can&rsquo;t make it fast and reliable.</p>
<p>We have a lot of tests in the <code>net/http</code> package which use this approach.
They&rsquo;re all slow and/or flaky, which is what started me down the road
which brings us here today.</p>
<h2 id="write-synchronous-functions">Write synchronous functions?</h2>
<p>The simplest way to test an asynchronous function is not to do it.
Synchronous functions are easy to test.
If you can transform an asynchronous function into a synchronous one,
it will be easier to test.</p>
<p>For example, if we consider our cache cleanup functions from earlier,
the synchronous <code>Cleanup</code> is obviously better than
the asynchronous <code>CleanupInBackground</code>.
The synchronous function is easier to test,
and the caller can easily start a new goroutine to run it in the background if needed.
As a general rule,
the higher up the call stack you can push your concurrency,
the better.</p>
<pre><code>// CleanupInBackground is hard to test.
cache.CleanupInBackground()

// Cleanup is easy to test,
// and easy to run in the background when needed.
go cache.Cleanup()
</code></pre>
<p>Unfortunately, this sort of transformation isn&rsquo;t always possible.
For example, <code>context.WithDeadline</code> is an inherently asynchronous API.</p>
<h2 id="instrument-code-for-testability">Instrument code for testability?</h2>
<p>A better approach is to make our code more testable.</p>
<p>Here&rsquo;s an example of what this might look like for our <code>WithDeadline</code> test:</p>
<pre><code>func TestWithDeadlineAfterDeadline(t *testing.T) {
    clock := fakeClock()
    timeout := 1 * time.Second
    deadline := clock.Now().Add(timeout)

    ctx, _ := context.WithDeadlineClock(
        t.Context(), deadline, clock)

    clock.Advance(timeout)
    context.WaitUntilIdle(ctx)
    if err := ctx.Err(); err != context.DeadlineExceeded {
        t.Fatalf(&quot;context not canceled after deadline&quot;)
    }
}
</code></pre>
<p>Instead of using real time, we use a fake time implementation.
Using fake time avoids unnecessarily slow tests,
because we never wait around doing nothing.
It also helps avoid test flakiness,
since the current time only changes when the test adjusts it.</p>
<p>There are various fake time packages out there,
or you can write your own.</p>
<p>To use fake time, we need to modify our API to accept a fake clock.
I&rsquo;ve added a <code>context.WithDeadlineClock</code> function here,
that takes an additional clock parameter:</p>
<pre><code>ctx, _ := context.WithDeadlineClock(
    t.Context(), deadline, clock)
</code></pre>
<p>When we advance our fake clock, we have a problem.
Advancing time is an asynchrounous operation.
Sleeping goroutines may wake up,
timers may send on their channels,
and timer functions may run.
We need to wait for that work to finish before we can test
the expected behavior of the system.</p>
<p>I&rsquo;ve added a <code>context.WaitUntilIdle</code> function here,
which waits for any background work related to a context to complete:</p>
<pre><code>clock.Advance(timeout)
context.WaitUntilIdle(ctx)
</code></pre>
<p>This is a simple example, but it demonstrates
the two fundamental principles of writing testable concurrent code:</p>
<ol>
<li>Use fake time (if you use time).</li>
<li>Have some way to wait for quiescence,
which is a fancy way of saying
&ldquo;all background activity has stopped and the system is stable&rdquo;.</li>
</ol>
<p>The interesting question, of course, is how we do this.
I&rsquo;ve glossed over the details in this example because
there are some big downsides to this approach.</p>
<p>It&rsquo;s hard.
Using a fake clock isn&rsquo;t difficult,
but identifying when background concurrent work is finished
and it is safe to examine the state of the system is.</p>
<p>Your code becomes less idiomatic.
You can&rsquo;t use standard time package functions.
You need to be very careful to keep track of everything happening
in the background.</p>
<p>You need to instrument not just your code,
but any other packages you use.
If you call any third-party concurrent code,
you&rsquo;re probably out of luck.</p>
<p>Worst of all, it can be just about impossible
to retrofit this approach into an existing codebase.</p>
<p>I attempted to apply this approach to Go&rsquo;s HTTP implementation,
and while I had some success at doing so in places,
the HTTP/2 server simply defeated me.
In particular, adding instrumentation to detect quiescence
without extensive rewriting proved infeasible,
or at least beyond my skills.</p>
<h2 id="horrible-runtime-hacks">Horrible runtime hacks?</h2>
<p>What do we do if we can&rsquo;t make our code testable?</p>
<p>What if instead of instrumenting our code,
we had a way to observe the behavior of the uninstrumented system?</p>
<p>A Go program consists of a set of goroutines.
Those goroutines have states.
We just need to wait until all the goroutines have stopped running.</p>
<p>Unfortunately, the Go runtime doesn&rsquo;t provide any way to tell what
those goroutines are doing. Or does it?</p>
<p>The <code>runtime</code> package contains a function that gives us a stack trace
for every running goroutine, as well as their states.
This is text intended for human consumption,
but we could parse that output.
Could we use this to detect quiescence?</p>
<p>Now, of course this is a terrible idea.
There is no guarantee that the format of these stack traces will be stable over time.
You should not do this.</p>
<p>I did it.
And it worked.
In fact, it worked surprisingly well.</p>
<p>With a simple implementation of a fake clock,
a small amount of instrumentation to keep track of what goroutines were part of the test,
and some horrifying abuse of <code>runtime.Stack</code>,
I finally had a way to write fast, reliable tests for the <code>http</code> package.</p>
<p>The underlying implementation of these tests was horrible,
but it demonstrated that there was a useful concept here.</p>
<h2 id="a-better-way">A better way</h2>
<p>Go may have built-in concurrency,
but testing programs that use that concurrency is hard.</p>
<p>We&rsquo;re faced with an unfortunate choice:
We can write simple, idiomatic code, but it will be impossible to test quickly and reliably;
or we can write testable code, but it will be complicated and unidiomatic.</p>
<p>So we asked ourselves what we can do to make this better.</p>
<p>As we saw earlier, the two fundamental features required to write testable concurrent code are
fake time and a way to wait for quiescence.</p>
<p>We need a better way to to wait for quiescence.
We should be able to ask the runtime when background goroutines have finished their work.
We also want to be able to limit the scope of this query to a single test,
so that unrelated tests do not interfere with each other.</p>
<p>We also need better support for testing programs using fake time.</p>
<p>It isn&rsquo;t hard to make a fake time implementation,
but code which uses an implementation like this is not idiomatic.</p>
<p>Idiomatic code will use a <code>time.Timer</code>,
but it is not possible to create a fake <code>Timer</code>.
We asked ourselves whether we should provide a way for tests to
create a fake <code>Timer</code>, where the test controls when the timer fires.</p>
<p>A testing implementation of time needs to define an entirely new version of the <code>time</code> package,
and pass that to every function that operates on time.
We considered whether we should define a common time interface,
in the same way that <code>net.Conn</code> is a common interface describing a network connection.</p>
<p>What we realized, however, is that unlike network connections,
there is only one possible implementation of fake time.
A fake network may want to introduce latency or errors.
Time, in contrast, does only one thing: It moves forward.
Tests need to control the rate at which time progresses,
but a timer scheduled to fire ten seconds in the future
should always fire ten (possibly fake) seconds in the future.</p>
<p>In addition, we don&rsquo;t want to upset the entire Go ecosystem.
Most programs today use functions in the time package.
We want to keep those programs not only working,
but idiomatic.</p>
<p>This led to the conclusion that what we need is a way for a test to
tell the time package to use a fake clock,
in much the same way that the Go playground uses a fake clock.
Unlike the playground,
we need to limit the scope of that change to a single test.
(It may not be obvious that the Go playground uses a fake clock,
because we turn any fake delays into real delays on the front end,
but it does.)</p>
<h2 id="the-synctest-experiment">The <code>synctest</code> experiment</h2>
<p>And so in Go 1.24 we introduced <a href="/pkg/testing/synctest"><code>testing/synctest</code></a>,
a new, experimental package to simplify testing concurrent programs.
Over the months following the release of Go 1.24
we gathered feedback from early adopters.
(Thank you to everyone who tried it out!)
We made a number of changes to address problems and shortcomings.
And now, in Go 1.25, we&rsquo;ve released the <code>testing/synctest</code> package
as part of the standard library.</p>
<p>It lets you run a function in what we&rsquo;re calling a &ldquo;bubble&rdquo;.
Within the bubble, the time package uses a fake clock,
and the <code>synctest</code> package provides a function to wait for the bubble to quiesce.</p>
<h2 id="the-synctest-package">The <code>synctest</code> package</h2>
<p>The <code>synctest</code> package contains just two functions.</p>
<pre><code>package synctest

// Test executes f in a new bubble.
// Goroutines in the bubble use a fake clock.
func Test(t *testing.T, f func(*testing.T))

// Wait waits for background activity in the bubble to complete.
func Wait()
</code></pre>
<p><a href="/pkg/testing/synctest#Test"><code>Test</code></a> executes a function in a new bubble.</p>
<p><a href="/pkg/testing/synctest#Wait"><code>Wait</code></a> blocks until every goroutine in the bubble is blocked
waiting for some other goroutine in the bubble.
We call that state being &ldquo;durably blocked&rdquo;.</p>
<h2 id="testing-with-synctest">Testing with synctest</h2>
<p>Let&rsquo;s look at an example of synctest in action.</p>
<pre><code>func TestWithDeadlineAfterDeadline(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        deadline := time.Now().Add(1 * time.Second)
        ctx, _ := context.WithDeadline(t.Context(), deadline)

        time.Sleep(time.Until(deadline))
        synctest.Wait()
        if err := ctx.Err(); err != context.DeadlineExceeded {
            t.Fatalf(&quot;context not canceled after deadline&quot;)
        }
    })
}
</code></pre>
<p>This might look a little familiar.
This is the na√Øve test for <code>context.WithDeadline</code> that we looked at earlier.
The only changes are that we&rsquo;ve wrapped the test in
a <code>synctest.Test</code> call to execute it in a bubble
and we have added a <code>synctest.Wait</code> call.</p>
<p>This test is fast and reliable.
It runs almost instantaneously.
It precisely tests the expected behavior of the system under test.
It also requires no modification of the <code>context</code> package.</p>
<p>Using the <code>synctest</code> package,
we can write simple, idiomatic code
and test it reliably.</p>
<p>This is a very simple example, of course,
but this is a real test of real production code.
If <code>synctest</code> had existed when the <code>context</code> package was written,
we would have had a much easier time writing tests for it.</p>
<h2 id="time">Time</h2>
<p>Time in the bubble behaves much the same as the fake time in the Go playground.
Time starts at midnight, January 1, 2000 UTC.
If you need to run a test at some specific point in time for some reason,
you can just sleep until then.</p>
<pre><code>func TestAtSpecificTime(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       // 2000-01-01 00:00:00 +0000 UTC
       t.Log(time.Now().In(time.UTC))

       // This does not take 25 years.
       time.Sleep(time.Until(
           time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)))

       // 2025-01-01 00:00:00 +0000 UTC
       t.Log(time.Now().In(time.UTC))
   })
}
</code></pre>
<p>Time only passes when every goroutine in the bubble has blocked.
You can think of the bubble as simulating an infinitely fast computer:
Any amount of computation takes no time.</p>
<p>The following test will always print that zero seconds
of fake time have elapsed since the start of the test,
no matter how much real time has passed.</p>
<pre><code>func TestExpensiveWork(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       start := time.Now()
       for range 1e7 {
           // do expensive work
       }
       t.Log(time.Since(start)) // 0s
   })
}
</code></pre>
<p>In the next test, the <code>time.Sleep</code> call will return immediately,
rather than waiting for ten real seconds.
The test will always print that exactly ten fake seconds
have passed since the start of the test.</p>
<pre><code>func TestSleep(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       start := time.Now()
       time.Sleep(10 * time.Second)
       t.Log(time.Since(start)) // 10s
   })
}
</code></pre>
<h2 id="waiting-for-quiescence">Waiting for quiescence</h2>
<p>The <a href="/pkg/testing/synctest#Wait"><code>synctest.Wait</code></a> function
lets us wait for background activity to complete.</p>
<pre><code>func TestWait(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       done := false
       go func() {
           done = true
       }()

       // Wait for the above goroutine to finish.
       synctest.Wait()

       t.Log(done) // true
   })
}
</code></pre>
<p>If we didn&rsquo;t have the <code>Wait</code> call in the above test,
we would have a race condition:
One goroutine modifies the <code>done</code> variable
while another reads from it without synchronization.
The <code>Wait</code> call provides that synchronization.</p>
<p>You may be familiar with the <code>-race</code> test flag,
which enables the data race detector.
The race detector is aware of the synchronization provided by <code>Wait</code>,
and does not complain about this test.
If we forgot the <code>Wait</code> call, the race detector would correctly complain.</p>
<p>The <code>synctest.Wait</code> function provides synchronization,
but the passage of time does not.</p>
<p>In the next example, one goroutine writes to the <code>done</code> variable
while another sleeps for one nanosecond before reading from it.
It should be obvious that when run with a real clock outside a synctest bubble,
this code contains a race condition.
Inside a synctest bubble,
while the fake clock ensures that the goroutine completes before <code>time.Sleep</code> returns,
the race detector will still report the data race,
just like it would if this code were run outside a synctest bubble.</p>
<pre><code>func TestTimeDataRace(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       done := false
       go func() {
           done = true // write
       }()

       time.Sleep(1 * time.Nanosecond)

       t.Log(done)     // read (unsynchronized)
   })
}
</code></pre>
<p>Adding a <code>Wait</code> call provides explicit synchronization and fixes the data race:</p>
<pre><code>time.Sleep(1 * time.Nanosecond)
synctest.Wait() // synchronize
t.Log(done)     // read
</code></pre>
<h2 id="example-iocopy">Example: <code>io.Copy</code></h2>
<p>Taking advantage of the synchronization provided by <code>synctest.Wait</code> allows us
to write simpler tests with less explicit synchronization.</p>
<p>For example, consider this test of <a href="/pkg/io#Copy"><code>io.Copy</code></a>.</p>
<pre><code>func TestIOCopy(t *testing.T) {
   synctest.Test(t, func(t *testing.T) {
       srcReader, srcWriter := io.Pipe()
       defer srcWriter.Close()

       var dst bytes.Buffer
       go io.Copy(&amp;dst, srcReader)

       data := &quot;1234&quot;
       srcWriter.Write([]byte(&quot;1234&quot;))
       synctest.Wait()

       if got, want := dst.String(), data; got != want {
           t.Errorf(&quot;Copy wrote %q, want %q&quot;, got, want)
       }
   })
}
</code></pre>
<p>The <code>io.Copy</code> function copies data from an <code>io.Reader</code> to an <code>io.Writer</code>.
You might not immediately think of <code>io.Copy</code> as a concurrent function,
since it blocks until the copy has completed.
However, providing data to <code>io.Copy</code>&rsquo;s reader is an asynchronous operation:</p>
<ul>
<li><code>Copy</code> calls the reader&rsquo;s <code>Read</code> method;</li>
<li><code>Read</code> returns some data;</li>
<li>and the data is written to the writer at a later time.</li>
</ul>
<p>In this test, we are verifying that <code>io.Copy</code> writes new data to the writer
without waiting to fill its buffer.</p>
<p>Looking at the test step by step,
we first create an <code>io.Pipe</code> to serve as the source <code>io.Copy</code> reads from:</p>
<pre><code>srcReader, srcWriter := io.Pipe()
defer srcWriter.Close()
</code></pre>
<p>We call <code>io.Copy</code> in a new goroutine,
copying from the read end of the pipe into a <code>bytes.Buffer</code>:</p>
<pre><code>var dst bytes.Buffer
go io.Copy(&amp;dst, srcReader)
</code></pre>
<p>We write to the other end of the pipe,
and wait for <code>io.Copy</code> to handle the data:</p>
<pre><code>data := &quot;1234&quot;
srcWriter.Write([]byte(&quot;1234&quot;))
synctest.Wait()
</code></pre>
<p>Finally, we verify that the destination buffer contains the desired data:</p>
<pre><code>if got, want := dst.String(), data; got != want {
    t.Errorf(&quot;Copy wrote %q, want %q&quot;, got, want)
}
</code></pre>
<p>We don&rsquo;t need to add a mutex or other synchronization around the destination buffer,
because <code>synctest.Wait</code> ensures that it is never accessed concurrently.</p>
<p>This test demonstrates a few important points.</p>
<p>Even synchronous functions like <code>io.Copy</code>,
which do not perform additional background work after they return,
may exhibit asynchronous behaviors.</p>
<p>Using <code>synctest.Wait</code>, we can test those behaviors.</p>
<p>Note also that this test does not work with time.
Many asynchronous systems involve time, but not all.</p>
<h2 id="bubble-exit">Bubble exit</h2>
<p>The <code>synctest.Test</code> function waits for all goroutines in the bubble to exit
before returning.
Time stops advancing after the root goroutine (the goroutine started by <code>Test</code>) returns.</p>
<p>In the next example, <code>Test</code> waits for the background goroutine to run and exit
before it returns:</p>
<pre><code>func TestWaitForGoroutine(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        go func() {
            // This runs before synctest.Test returns.
        }()
    })
}
</code></pre>
<p>In this example, we schedule a <code>time.AfterFunc</code> for a time in the future.
The bubble&rsquo;s root goroutine returns before that time is reached,
so the <code>AfterFunc</code> never runs:</p>
<pre><code>func TestDoNotWaitForTimer(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        time.AfterFunc(1 * time.Nanosecond, func() {
            // This never runs.
        })
    })
}
</code></pre>
<p>In the next example, we start a goroutine that sleeps.
The root goroutine returns and time stops advancing.
The bubble is now deadlocked,
because <code>Test</code> is waiting for all goroutines in the bubble to finish
but the sleeping goroutine is waiting for time to advance.</p>
<pre><code>func TestDeadlock(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        go func() {
            // This sleep never returns and the test deadlocks.
            time.Sleep(1 * time.Nanosecond)
        }()
    })
}
</code></pre>
<h2 id="deadlocks">Deadlocks</h2>
<p>The <code>synctest</code> package panics when a bubble is deadlocked
due to every goroutine in the bubble being durably blocked on
another goroutine in the bubble.</p>
<pre><code>--- FAIL: Test (0.00s)
--- FAIL: TestDeadlock (0.00s)
panic: deadlock: main bubble goroutine has exited but blocked goroutines remain [recovered, repanicked]

goroutine 7 [running]:
(stacks elided for clarity)

goroutine 10 [sleep (durable), synctest bubble 1]:
time.Sleep(0x1)
    /Users/dneil/src/go/src/runtime/time.go:361 +0x130
_.TestDeadlock.func1.1()
    /tmp/s/main_test.go:13 +0x20
created by _.TestDeadlock.func1 in goroutine 9
    /tmp/s/main_test.go:11 +0x24
FAIL    _   0.173s
FAIL
</code></pre>
<p>The runtime will print stack traces for every goroutine in the deadlocked bubble.</p>
<p>When printing the status of a bubbled goroutine,
the runtime indicates when the goroutine is durably blocked.
You can see that the sleeping goroutine in this test is durably blocked.</p>
<h2 id="durable-blocking">Durable blocking</h2>
<p>&ldquo;Durably blocking&rdquo; is a core concept in synctest.</p>
<p>A goroutine is durably blocked when it is not only blocked,
but when it can only be unblocked by another goroutine in the same bubble.</p>
<p>When every goroutine in a bubble is durably blocked:</p>
<ol>
<li><code>synctest.Wait</code> returns.</li>
<li>If there is no <code>synctest.Wait</code> call in progress,
fake time advances instantly to the next point that will wake a goroutine.</li>
<li>If there is no goroutine that can be woken by advancing time,
the bubble is deadlocked and the test fails.</li>
</ol>
<p>It is important for us to make a distinction between a goroutine which is merely blocked
and one which is <em>durably</em> blocked.
We don&rsquo;t want to declare a deadlock when a goroutine is temporarily blocked on
some event arising outside its bubble.</p>
<p>Let&rsquo;s look at some ways in which a goroutine can block non-durably.</p>
<h3 id="not-durably-blocking-io-files-pipes-network-connections-etc">Not durably blocking: I/O (files, pipes, network connections, etc.)</h3>
<p>The most important limitation is that I/O is not durably blocking,
including network I/O.
A goroutine reading from a network connection may be blocked,
but it will be unblocked by data arriving on that connection.</p>
<p>This is obviously true for a connection to some network service,
but it is also true for a loopback connection,
even when the reader and writer are both in the same bubble.</p>
<p>When we write data to a network socket,
even a loopback socket,
the data is passed to the kernel for delivery.
There is a period of time between the write system call returning
and the kernel notifying the other side of the connection that data is available.
The Go runtime cannot distinguish between a goroutine blocked waiting for
data that is already in the kernel&rsquo;s buffers
and one blocked waiting for data that will not arrive.</p>
<p>This means that tests of networked programs using synctest
usually cannot use real network connections.
Instead, they should use an in-memory fake.</p>
<p>I&rsquo;m not going to go over the process of creating a fake network here,
but the <code>synctest</code> package documentation contains
<a href="/pkg/testing/synctest#hdr-Example__HTTP_100_Continue">a complete worked example</a>
of testing an HTTP client and server communicating over a fake network.</p>
<h3 id="not-durably-blocking-syscalls-cgo-calls-anything-that-isnt-go">Not durably blocking: syscalls, cgo calls, anything that isn&rsquo;t Go</h3>
<p>Syscalls and cgo calls are not durably blocking.
We can only reason about the state of goroutines executing Go code.</p>
<h3 id="not-durably-blocking-mutexes">Not durably blocking: Mutexes</h3>
<p>Perhaps surprisingly, mutexes are not durably blocking.
This is a decision born of practicality:
Mutexes are often used to guard global state,
so a bubbled goroutine will often need to acquire a mutex held outside its bubble.
Mutexes are highly performance-sensitive,
so adding additional instrumentation to them
risks slowing down non-test programs.</p>
<p>We can test programs that use mutexes with synctest,
but the fake clock will not advance while a goroutine is blocked on mutex acquisition.
This hasn&rsquo;t posed a problem in any case we&rsquo;ve encountered,
but it is something to be aware of.</p>
<h3 id="durably-blocking-timesleep">Durably blocking: <code>time.Sleep</code></h3>
<p>So what is durably blocking?</p>
<p><code>time.Sleep</code> is obviously durable,
since time can only advance when every goroutine in the bubble is durably blocked.</p>
<h3 id="durably-blocking-send-or-receive-on-channels-created-in-the-same-bubble">Durably blocking: send or receive on channels created in the same bubble</h3>
<p>Channel operations on channels created within the same bubble are durable.</p>
<p>We make a distinction between bubbled channels (created in a bubble)
and unbubbled channels (created outside any bubble).
This means that a function using a global channel for synchronization,
for example to control access to a globally cached resource,
can be safely called from within a bubble.</p>
<p>Trying to operate on a bubbled channel from outside its bubble is an error.</p>
<h3 id="durably-blocking-syncwaitgroup-belonging-to-the-same-bubble">Durably blocking: <code>sync.WaitGroup</code> belonging to the same bubble</h3>
<p>We also associate <code>sync.WaitGroup</code>s with bubbles.</p>
<p><code>WaitGroup</code> doesn&rsquo;t have a constructor,
so we make the association with the bubble implicitly on the first call to <code>Go</code> or <code>Add</code>.</p>
<p>As with channels,
waiting on a <code>WaitGroup</code> belonging to the same bubble is durably blocking,
and waiting on one from outside the bubble is not.
Calling <code>Go</code> or <code>Add</code> on a <code>WaitGroup</code> belonging to a different bubble is an error.</p>
<h3 id="durably-blocking-synccondwait">Durably blocking: <code>sync.Cond.Wait</code></h3>
<p>Waiting on a <code>sync.Cond</code> is always durably blocking.
Waking up a goroutine waiting on a <code>Cond</code> in a different bubble is an error.</p>
<h3 id="durably-blocking-select">Durably blocking: <code>select{}</code></h3>
<p>Finally, an empty select is durably blocking.
(A select with cases is durably blocking if all the operations in it are so.)</p>
<p>That&rsquo;s the complete list of durably blocking operations.
It isn&rsquo;t very long,
but it&rsquo;s enough to handle almost all real-world programs.</p>
<p>The rule is that a goroutine is durably blocked when it is blocked,
and we can guarantee that it can only be unblocked
by another goroutine in its bubble.</p>
<p>In cases where it is possible to attempt to wake a bubbled goroutine from outside its bubble,
we panic.
For example, it is an error to operate on a bubbled channel from outside its bubble.</p>
<h2 id="changes-from-124-to-125">Changes from 1.24 to 1.25</h2>
<p>We released an experimental version of the <code>synctest</code> package in Go 1.24.
To ensure that early adopters were aware of the experimental status of the package,
you needed to set a GOEXPERIMENT flag to make the package visible.</p>
<p>The feedback we received from those early adopters was invaluable,
both in demonstrating that the package is useful
and in uncovering areas where the API needed work.</p>
<p>These are some of the changes made between the experimental version
and the version released in Go 1.25.</p>
<h3 id="replaced-run-with-test">Replaced Run with Test</h3>
<p>The original version of the API created a bubble with a <code>Run</code> function:</p>
<pre><code>// Run executes f in a new bubble.
func Run(f func())
</code></pre>
<p>It became clear that we needed a way to create a <code>*testing.T</code>
that is scoped to a bubble.
For example, <code>t.Cleanup</code> should run cleanup functions in the same bubble
they are registered in, not after the bubble exits.
We renamed <code>Run</code> to <code>Test</code> and made it create a <code>T</code> scoped to the lifetime
of the new bubble.</p>
<h3 id="time-stops-when-a-bubbles-root-goroutine-returns">Time stops when a bubble&rsquo;s root goroutine returns</h3>
<p>We originally continued to advance time within a bubble for so long as
the bubble contained any goroutines waiting for future events.
This turned out to be very confusing when a long-lived goroutine never returned,
such as a goroutine reading forever from a <code>time.Ticker</code>.
We now stop advancing time when a bubble&rsquo;s root goroutine returns.
If the bubble is blocked waiting for time to advance,
this results in a deadlock and a panic which can be analyzed.</p>
<h3 id="removed-cases-where-durable-wasnt">Removed cases where &ldquo;durable&rdquo; wasn&rsquo;t</h3>
<p>We cleaned up the definition of &ldquo;durably blocking&rdquo;.
The original implementation had cases where a durably blocked goroutine could
be unblocked from outside the bubble.
For example, channels recorded whether they were created in a bubble,
but not which in which bubble they were created,
so one bubble could unblock a channel in a different bubble.
The current implementation contains no cases we know of
where a durably blocked goroutine can be unblocked from outside its bubble.</p>
<h3 id="better-stack-traces">Better stack traces</h3>
<p>We made improvements to the information printed in stack traces.
When a bubble deadlocks, we by default now only print stacks for the goroutines in that bubble.
Stack traces also clearly indicate which goroutines in a bubble are durably blocked.</p>
<h3 id="randomized-events-happening-at-the-same-time">Randomized events happening at the same time</h3>
<p>We made improvements to the randomization of events happening at the same time.
Originally, timers scheduled to fire at the same instant
would always do so in the order they were created.
This ordering is now randomized.</p>
<h2 id="future-work">Future work</h2>
<p>We&rsquo;re pretty happy with the synctest package at the moment.</p>
<p>Aside from the inevitable bug fixes,
we don&rsquo;t currently expect any major changes to it in the future.
Of course, with wider adoption it is always possible that we&rsquo;ll discover something
that needs doing.</p>
<p>One possible area of work is to improve the detection of durably blocked goroutines.
It would be nice if we could make mutex operations durably blocking,
with a restriction that a mutex acquired in a bubble must be released
from within the same bubble.</p>
<p>Testing networked code with synctest requires a fake network.
The <code>net.Pipe</code> function can create a fake <code>net.Conn</code>,
but there is currently no standard library function that creates
a fake <code>net.Listener</code> or <code>net.PacketConn</code>.
In addition, the <code>net.Conn</code> returned by <code>net.Pipe</code> is synchronous&ndash;every write blocks
until a read consumes the data&ndash;which is not representative of real network behavior.
Perhaps we should add a good fake implementations of common network interfaces
to the standard library.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That&rsquo;s the <code>synctest</code> package.</p>
<p>I can&rsquo;t say that it makes testing concurrent code simple,
because concurrency is never simple.
What it does is let you write the simplest possible concurrent code,
using idiomatic Go,
and the standard time package,
and then write fast, reliable tests for it.</p>
<p>I hope you find it useful.</p>
</div>

    </div>

    
    <div class="Article prevnext">
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <p>
        
          
            <b>Next article: </b><a href="/blog/jsonv2-exp">A new experimental Go API for JSON</a><br>
          
        
        
          
            <b>Previous article: </b><a href="/blog/container-aware-gomaxprocs">Container-aware GOMAXPROCS</a><br>
          
        
        <b><a href="/blog/all">Blog Index</a></b>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    </div>
    

  </div>
</div>

<script src="/js/play.js"></script>

</div>
          </li>
  
        </ul>
      </div>
  
      <div class="card">
        <h2>Reddit</h2>
  
        <h3 class="subreddit">r/golang</h3>
        <ul class="item-list">
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1r5zbic/gos_cryptography_packages_were_audited_the_results/" target="_blank">Go's Cryptography Packages Were Audited: The Results</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/golang/comments/1r5zbic/gos_cryptography_packages_were_audited_the_results/">  </a> </td><td> &#32; submitted by &#32; <a href="https://www.reddit.com/user/gamerdevguy"> /u/gamerdevguy </a> <br/> <span><a href="https://hackernoon.com/gos-cryptography-packages-were-audited-the-results">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1r5zbic/gos_cryptography_packages_were_audited_the_results/">[comments]</a></span> </td></tr></table></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1r5lzmy/whats_the_best_way_to_control_chrome_from_go/" target="_blank">What's the best way to control Chrome from Go?</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/golang/comments/1r5lzmy/whats_the_best_way_to_control_chrome_from_go/">  </a> </td><td> <!-- SC_OFF --><div class="md"><p>I built a small HTTP server (~1100 LOC) that wraps chromedp to give AI agents browser control. It works, but I&#39;m wondering if I&#39;m using the right tool for the job.</p> <p>Currently using:</p> <p>‚Ä¢ <strong>chromedp</strong> for CDP communication</p> <p>‚Ä¢ Raw DOM.resolveNode / Runtime.callFunctionOn for element interaction</p> <p>‚Ä¢ Accessibility.getFullAXTree for the a11y tree (main interface ‚Äî cheaper than screenshots for AI)</p> <p>‚Ä¢ Single sync.Mutex per tab context</p> <p>Things that feel clunky:</p> <p>‚Ä¢ chromedp&#39;s context-per-tab model ‚Äî managing lifecycles gets messy</p> <p>‚Ä¢ No built-in way to get the accessibility tree (had to use raw CDP calls)</p> <p>‚Ä¢ Stealth flags keep getting deprecated by Chrome</p> <p><strong>Is chromedp still the best option?</strong> I&#39;ve looked at:</p> <p>‚Ä¢ Raw CDP via <a href="http://github.com/mafredri/cdp">github.com/mafredri/cdp</a> ‚Äî more control, more work</p> <p>‚Ä¢ Rod (go-rod/rod) ‚Äî supposedly simpler API?</p> <p>‚Ä¢ Calling Playwright via subprocess ‚Äî feels wrong from Go</p> <p>‚Ä¢ Direct WebSocket to Chrome DevTools ‚Äî maximum control but maintaining it yourself</p> <p>Anyone using something different? Or is chromedp + raw CDP the way to go?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Fit_Audience_7470"> /u/Fit_Audience_7470 </a> <br/> <span><a href="http://github.com/pinchtab/pinchtab">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1r5lzmy/whats_the_best_way_to_control_chrome_from_go/">[comments]</a></span> </td></tr></table></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1r5c00m/lunar_a_selfhosted_golanglua_faas_for_personal_use/" target="_blank">Lunar: a self-hosted Golang+Lua FaaS for personal use.</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/golang/comments/1r5c00m/lunar_a_selfhosted_golanglua_faas_for_personal_use/">  </a> </td><td> <!-- SC_OFF --><div class="md"><p>Last holidays, I wanted to automate a few things and ended up creating Lunar, which is a lightweight faas platform, sqlite backed, and single binary deployment, where functions are written in Lua. </p> <p>Let me know what you think, and feel free to contribute to the project; you can find a few ideas listed in the contributions file.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/claudemiro"> /u/claudemiro </a> <br/> <span><a href="https://github.com/dimiro1/lunar">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1r5c00m/lunar_a_selfhosted_golanglua_faas_for_personal_use/">[comments]</a></span> </td></tr></table></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1r59r3c/you_like_typing_and_you_are_a_fan_terminal_you/" target="_blank">You like typing and you are a fan terminal ? You will love this ? The new version of COUIK is out with new UI and new features</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>New features:</p> <p>- You get a little chart at the end to see how you did over time<br/> - Logo configuration<br/> - A new minimalist UI<br/> - Command palette guide (CTRL + P)<br/> - Config display</p> <p>repo &amp; install guide : <a href="https://github.com/Fadilix/couik">https://github.com/Fadilix/couik</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/TemporaryStrong6968"> /u/TemporaryStrong6968 </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1r59r3c/you_like_typing_and_you_are_a_fan_terminal_you/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1r59r3c/you_like_typing_and_you_are_a_fan_terminal_you/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/golang/comments/1r59qbo/why_i_am_getting_this_problem_when_i_try_to/" target="_blank">Why I am getting this problem when i try to install go 1.26??</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p><strong>&quot;This installation package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer package.&quot;</strong></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/infinity1009"> /u/infinity1009 </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/1r59qbo/why_i_am_getting_this_problem_when_i_try_to/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/1r59qbo/why_i_am_getting_this_problem_when_i_try_to/">[comments]</a></span></div>
          </li>
  
        </ul>
  
        <h3 class="subreddit">r/rust</h3>
        <ul class="item-list">
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5yykx/i_built_a_zerolatency_evm_indexer_in_rust_71k/" target="_blank">i built a zero-latency evm indexer in rust (71k tx/sec throughput)</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>hey guys. not sure if this is the right place to share, but heres something I&#39;ve been working on for a while</p> <p>basically ive been working on my own reth exex, called shadow index. heres a short glimpse of it</p> <p>its a zero-latency evm indexer (reth exex + clickhouse)</p> <p>current status * core pipeline complete. * 37/37 tests passing (unit + integration). * dockerized + prometheus metrics wired up.</p> <p>performance (dummy data stress test) * throughput: 7,159 blocks/sec | 71,592 txs/sec. * latency: 4.08ms median | 6.30ms max (block received to db flush). * context: standard rpcs take 50-500ms just to return data over the network. this writes to disk in 4ms.</p> <p>architecture flexes * zero rpc overhead: runs entirely in-process with the reth node. memory-to-memory. * native reorg handling: built on clickhouse CollapsingMergeTree. automatically cancels reverted blocks (sign = -1) without messy state rollbacks. * state diffs: extracts exact storage slot changes directly from evm BundleState. * bulletproof: custom circuit breaker, exponential backoff, and atomic cursor persistence (never loses its place on restart).</p> <p>what&#39;s underway * api layer: spinning up a highly concurrent read-only rest api via axum for frontend consumption. * ci: wiring up github actions. * the live test: deploying a 24-hour live sync on sepolia to prove out memory stability and network reorgs.</p> <p>id love any suggestions or reviews based on just this piece of text and the benchmarks :)</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/the-bit2swaz"> /u/the-bit2swaz </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5yykx/i_built_a_zerolatency_evm_indexer_in_rust_71k/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5yykx/i_built_a_zerolatency_evm_indexer_in_rust_71k/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5yu52/composable_configuration_idea_for_apps_and/" target="_blank">Composable configuration idea for apps and libraries</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I&#39;d like to share with you a new config crate <a href="https://github.com/kamu-data/setty"><code>setty</code></a>.</p> <p>I wrote it after 4 years of trying all major options like <code>config</code>, <code>figment</code>, <code>confique</code>, and still struggling with configs in our complex CLI app and across many production services (k8s).</p> <p>It solves a few basic problems like:</p> <ul> <li>Hiding multiple libraries (<code>serde</code>, <code>schemars</code>, <code>validator</code>, <code>better_default</code>) behind one macro</li> <li>Merging values from multiple files and env vars <em>(enums make this not so trivial)</em></li> <li>Generating nice markdown docs and JSONSchema for Helm charts</li> <li>CLI Completions</li> <li>Deprecation warnings etc.</li> </ul> <p>But the most interesting design aspect is - it <strong>externalizes your config style preferences into crate features</strong>.</p> <p>This means you can use <code>setty</code> in libraries to define reusable config DTOs, then directly embed those types into your application config, without libraries having to know anything about whether application wants <code>camelCase</code> or <code>kebab-case</code>, what enum representation it prefers, whether to derive <code>JsonSchema</code> or not, etc. - all these decisions are made in the app&#39;s <code>Cargo.toml</code> and propagate down to the libraries via feature additivity.</p> <p>Readme has a simple example, and here&#39;s one from <a href="https://github.com/kamu-data/kamu-cli/blob/6cec24db756cabac38928aec049f03ac5feccb39/src/app/cli/src/services/config/models.rs">prod app</a>.</p> <p>Your feedback is welcome!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/sergiimk"> /u/sergiimk </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5yu52/composable_configuration_idea_for_apps_and/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5yu52/composable_configuration_idea_for_apps_and/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5wycd/simple_grammar_checker_with_iced_and_harper/" target="_blank">Simple Grammar Checker with Iced and Harper</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Disclaimer: I used AI to facilitate the process, as I don&#39;t have much time to do side projects, and I really wanted to do this.</p> <p>I work 5 to 6 days at week as a developer, constantly changing code, adding features, well, the usual. I&#39;m always opening PRs, and as a good professional that I&#39;m trying to be, I try to sound good in a description, try to be concise, and so on.</p> <p>From 0 to 50 times a day I go to ChatGPT and say something like:</p> <p><code>fix grammar of this: &lt;Enter PR description&gt;</code> </p> <p>I usually don&#39;t commit many mistakes while typing but I type fast and I can easily eat an apostrophe, a comma, something.</p> <p>So using ChatGPT for this all the time is inefficient, it might not be that slow, but it&#39;s slower compared to this. So on my free time I created Aella (A random Greek name I liked), a simple app that checks grammar offline (Only English at the moment), fast, and you just keep your tone. For me it lets me keep my ideas over a paragraph.</p> <p>For instance, I type my PR description, copy it to clipboard then in a terminal <code>echo &quot;$pbpaste&quot; | aella check | pbcopy</code>, done. Or I can use the Awesome Icy Desktop App.</p> <p>The project is 100% Rust, it is a beta/alpha some of that, many bugs might arise (I hope not), and many features are yet to be added, many things that the CLI has, can be added to the desktop too. Mainly the idea was to build only a Desktop App, but the CLI is power!</p> <p><a href="https://preview.redd.it/ia75h2o7mrjg1.jpg?width=1624&amp;format=pjpg&amp;auto=webp&amp;s=cc170e7a5fd323b08a109c3e19672221cad194b1">https://preview.redd.it/ia75h2o7mrjg1.jpg?width=1624&amp;format=pjpg&amp;auto=webp&amp;s=cc170e7a5fd323b08a109c3e19672221cad194b1</a></p> <p><a href="https://github.com/ARKye03/aella">https://github.com/ARKye03/aella</a></p> <p>I just wanted to share this project, so if anyone finds it interesting, can use or whatever, I think it is kinda cute. I usually don&#39;t post other projects of mine.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/ARKyal03"> /u/ARKyal03 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5wycd/simple_grammar_checker_with_iced_and_harper/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5wycd/simple_grammar_checker_with_iced_and_harper/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5r1u6/can_message_passing_be_implemented_with_less_code/" target="_blank">Can message passing be implemented with less code in C++?</a>
            <div class="item-content">&#32; submitted by &#32; <a href="https://www.reddit.com/user/pietrom16"> /u/pietrom16 </a> <br/> <span><a href="/r/cpp_questions/comments/1r5qztl/can_message_passing_be_implemented_with_less_code/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5r1u6/can_message_passing_be_implemented_with_less_code/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5quld/minimalistic_zed_flavor/" target="_blank">Minimalistic Zed Flavor</a>
            <div class="item-content">&#32; submitted by &#32; <a href="https://www.reddit.com/user/Tux-Lector"> /u/Tux-Lector </a> <br/> <span><a href="/r/ZedEditor/comments/1r2zs5z/minimalistic_zed_flavor/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5quld/minimalistic_zed_flavor/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5pfcs/best_library_for_secret_sharing/" target="_blank">Best library for secret sharing?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hey,</p> <p>I&#39;ve noticed that there are a few Rust libraries for Shamir Secret Sharing (SSS) and some of its variants.</p> <p>Some are pretty old, some are newer, none of them seem especially popular or under active development. I just wanted to know if anyone here has experience with any of the libraries and whether he/she recommends it. I need to use SSS in a personal project, and I wonder if I should use any of these or implement it from scratch.</p> <p>A related question, would be if SSS (and related schemes like VSS or TSS) would fit within RustCrypto? If so, I might be interested in contributing to this.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/ruggedcatfish"> /u/ruggedcatfish </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5pfcs/best_library_for_secret_sharing/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5pfcs/best_library_for_secret_sharing/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5owrc/advanced_graphing_in_the_terminal_termplt/" target="_blank">Advanced Graphing in the Terminal: termplt</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p><a href="https://preview.redd.it/5sx5hrkrvpjg1.png?width=2126&amp;format=png&amp;auto=webp&amp;s=d355b4fd9a51fc3103bdc5fe521c99dfb3d394d3">https://preview.redd.it/5sx5hrkrvpjg1.png?width=2126&amp;format=png&amp;auto=webp&amp;s=d355b4fd9a51fc3103bdc5fe521c99dfb3d394d3</a></p> <p>Finally published a project I&#39;ve been working on for a while to provide more sophisticated graphing support directly in the terminal.</p> <p>Currently only runs on Linux and MacOS (requires `nix` crate) and requires a terminal that supports the <a href="https://sw.kovidgoyal.net/kitty/graphics-protocol/">Kitty Graphics Protocol</a> (Kitty, WezTerm, Ghostty, etc.). Screenshot was captured on MacOS in WezTerm.</p> <p>GitHub: <a href="https://github.com/EdCarney/termplt">https://github.com/EdCarney/termplt</a></p> <p>Crate: <a href="https://crates.io/crates/termplt">https://crates.io/crates/termplt</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/NullRefEd"> /u/NullRefEd </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5owrc/advanced_graphing_in_the_terminal_termplt/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5owrc/advanced_graphing_in_the_terminal_termplt/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5m0rz/i_made_a_package_manager_for_github/" target="_blank">I made a package manager for Github</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Updating apps from github releases is manual and somewhat annoying, so I made an app that does it for you!<br/> It can download assets from Github/Gitlab as well as discovering links from websites directly (e.g. <a href="https://ziglang.org/download/">https://ziglang.org/download/</a>) </p> <p>I feel that its feature complete enough for a more public release. I hope its as useful to you as it is for me.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/what486"> /u/what486 </a> <br/> <span><a href="https://github.com/what386/upstream-rs">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5m0rz/i_made_a_package_manager_for_github/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5lqer/why_does_clippy_encourage_stringpusha_over/" target="_blank">Why does clippy encourage `String::push('a')` over `String::push_str(''a")`?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>One thing that has always been annoying me is clippy telling me to use <code>String::push(c: char)</code> instead of <code>String::push_str(s: &amp;str)</code> to append a single character <code>&amp;&#39;static str</code>. To me this makes no sense. Why should my program decode a utf-8 codepoint from a 32 bit char instead of just copying over 1-4 bytes from a slice? </p> <p>I did some benchmarks and found <code>push_str</code> to be 5-10% faster for appending a single byte string. </p> <p>Not that this matters much but I find clippy here unnecessarily opinionated with no benefit to the program.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/MediumInsect7058"> /u/MediumInsect7058 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5lqer/why_does_clippy_encourage_stringpusha_over/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5lqer/why_does_clippy_encourage_stringpusha_over/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5ku44/the_next_chromeedge_releases_will_credit_the_150/" target="_blank">The next Chrome/Edge releases will credit the ~150 Rust crates they use</a>
            <div class="item-content">&#32; submitted by &#32; <a href="https://www.reddit.com/user/fintelia"> /u/fintelia </a> <br/> <span><a href="https://chromium-review.googlesource.com/c/chromium/src/+/7514149">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5ku44/the_next_chromeedge_releases_will_credit_the_150/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5h362/2d_collision_system_that_can_work_in_parallel/" target="_blank">2d collision system that can work in parallel</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hello all,</p> <p>I&#39;m building a game server for an rts like game.</p> <p>I&#39;m using bevy_ecs and got to the point where I need some kind of collision. I just need entities not to step on each other so some kind of collision framework that uses a quad or any kind of spatial partition system under the hood.</p> <p>I started integrating bevy_rapier2d but the way I have it setup is I have several zones and they are completely independent from each other so I calculate the tick of each zone in tokyo tasks. And bevy_rapier2d integrates into Bevy App system that is not Send so I cannot have a different App for each zone.</p> <p>Now I moved to base rapied_2d and it seems like it could work but the full tick loop is a bit awkward:</p> <p>- Run the ecs logic</p> <p>- Sync all the entities position into the physics system (the colliders and rigidbodies)</p> <p>- Tick the physics world</p> <p>- Sync back all the positions from the physics system to the ecs system</p> <p>Anybody has done anything similar?</p> <p>Any suggestions are welcome</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/PlateFox"> /u/PlateFox </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5h362/2d_collision_system_that_can_work_in_parallel/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5h362/2d_collision_system_that_can_work_in_parallel/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5ecfy/bluedb_building_a_buffer_pool_in_rust/" target="_blank">BlueDB - Building a Buffer pool in Rust</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p><a href="https://preview.redd.it/jlt0l6grvnjg1.png?width=822&amp;format=png&amp;auto=webp&amp;s=cb82b4d586a616377f0008e713fd57e3ce154865">https://preview.redd.it/jlt0l6grvnjg1.png?width=822&amp;format=png&amp;auto=webp&amp;s=cb82b4d586a616377f0008e713fd57e3ce154865</a></p> <p>Hello, would like to share awesome thing I was working on</p> <p>I have built a buffer pool in Rust, the goal of my work is to build a complete RDBMS in rust, this is the first building block that will be wrapped by a storage engine soon</p> <p>I have seen multiple eviction algorithms, but started to think what about instead of implementing an algorithm as the book says, why not just think about the most logical one for my case now ? and finally I found myself implementing a N-Chances clock algorithm</p> <p>my logic is so simple, the evictor is telling each page the following &quot;Hey page, I warn you that if you aren&#39;t used for X loops sequentially, I will evict you&quot;</p> <p>regarding locking, imagine the buffer pool is telling the transaction &quot;Hey txn, take this guard of the page (acquire), once you are done return it back (release)&quot;</p> <p>finally, I am thinking about what to build over this buf pool, one of the ideas that blow my mind is to expose it as a server, where a transaction processing client will communicate with the buffer server, it is very interesting idea to implement funny complex things !</p> <p>btw, rust is very amazing lang to write complex software, very happy to have discovered it !</p> <p>Gtihub repo: <a href="https://github.com/ahmed-kamal2004/bluedb">https://github.com/ahmed-kamal2004/bluedb</a></p> <p>Would love to see your stars!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/GainRemarkable1339"> /u/GainRemarkable1339 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5ecfy/bluedb_building_a_buffer_pool_in_rust/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5ecfy/bluedb_building_a_buffer_pool_in_rust/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5cpml/i_built_tokiofsm_proc_macro_for_compiletime/" target="_blank">I built tokio-fsm: proc macro for compile-time validated async state machines</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Tired of writing the same event loop + channel + timeout boilerplate for every stateful async workflow. tokio-fsm discovers states/events from your code and validates transitions at compile time. I am inspired by the work I found myself doing recently and thought there is a gap, plus I love compile-time macros.</p> <p>```rust</p> <h1>[fsm(initial = Idle)]</h1> <p>impl Connection { type Context = ConnectionCtx; type Error = std::io::Error;</p> <pre><code>#[on(state = Idle, event = Connect)] async fn start(&amp;mut self) -&gt; Transition&lt;Connecting&gt; { Transition::to(Connecting) } #[on(state = Connecting, event = Success)] #[state_timeout(duration = &quot;30s&quot;)] async fn connected(&amp;mut self) -&gt; Transition&lt;Active&gt; { Transition::to(Active) } </code></pre> <p>} ```</p> <p>Invalid transitions = compile errors. Unreachable states = compile errors. Built-in timeouts, channels, background tasks.</p> <p><strong>Realistic example:</strong> <a href="https://github.com/abhishekshree/tokio-fsm/tree/main/examples/axum_fsm">Axum order processing</a> showing multi-instance FSM management via HTTP.</p> <ul> <li>Crates: <a href="https://crates.io/crates/tokio-fsm">https://crates.io/crates/tokio-fsm</a></li> <li>Docs: <a href="https://docs.rs/tokio-fsm">https://docs.rs/tokio-fsm</a></li> <li>Repo: <a href="https://github.com/abhishekshree/tokio-fsm">https://github.com/abhishekshree/tokio-fsm</a></li> </ul> <p><strong>Looking for feedback on:</strong></p> <ul> <li>API ergonomics (does <code>#[on(state = X, event = Y)]</code> feel natural?)</li> <li>Missing features for real-world usage</li> <li>Documentation gaps</li> </ul> <p>Issues/PRs welcome. Still learning Rust ecosystem best practices.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/shree_ee"> /u/shree_ee </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5cpml/i_built_tokiofsm_proc_macro_for_compiletime/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5cpml/i_built_tokiofsm_proc_macro_for_compiletime/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5ccar/media_rsiv_a_scriptable_vimlike_image_viewer_a/" target="_blank">[Media] rsiv: A scriptable, vim-like image viewer (a rewrite & extension of nsxiv) built with winit and pixels.</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Hey <a href="/r/rust">r/rust</a>! ü¶Ä</p> <p>This is my first &quot;real&quot; rust project and I&#39;ve just hit a point where this project feels polished enough to share.</p> <p><code>rsiv</code> aims to be a modern rewrite of <a href="https://codeberg.org/nsxiv/nsxiv">nsxiv</a> , bringing native Wayland support and standard configuration. But it also extends the original feature set most notably with live, fuzzy-matched filtering. You can see an example of this in the bottom right of the screenshot!</p> <p><strong>GitHub:</strong> <a href="https://github.com/miniaoumiae/rsiv">https://github.com/miniaoumiae/rsiv</a></p> <p>I&#39;d love to hear your feedback, bug reports, or any critiques on the code structure!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Brilliant-Bit-8724"> /u/Brilliant-Bit-8724 </a> <br/> <span><a href="https://i.redd.it/3hjdbbd68njg1.png">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5ccar/media_rsiv_a_scriptable_vimlike_image_viewer_a/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5bqhy/salvo_vs_axum_why_is_axum_so_much_more_popular/" target="_blank">Salvo vs Axum ‚Äî why is Axum so much more popular?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I‚Äôve been playing with both Salvo and Axum lately, and something I can‚Äôt wrap my head around is why Axum is so much more popular.</p> <p>From a developer experience point of view, Salvo feels surprisingly complete. A lot of the things I usually need are already there, and I don‚Äôt have to think too much about adding extra crates for common backend tasks. With Axum, I often end up assembling the stack myself, which isn‚Äôt bad, just different.</p> <p>I can‚Äôt really figure out why Axum gets so much more attention while Salvo barely comes up in discussions. From what I‚Äôve seen so far, Salvo feels pretty capable and well thought out. Maybe I‚Äôm missing something, maybe not.</p> <p>What do you all think about this?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Sensitive-Raccoon155"> /u/Sensitive-Raccoon155 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5bqhy/salvo_vs_axum_why_is_axum_so_much_more_popular/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5bqhy/salvo_vs_axum_why_is_axum_so_much_more_popular/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5bneg/custom_discriminant_for_enum_types/" target="_blank">Custom discriminant for enum types?</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I&#39;m building a high performance merkle tree for a research paper. I&#39;m using the arena approach, i.e.: I allocate a very big array and then each node use a <code>type ArenaID = (u8, u16)</code> as pointer. To simplify I have 3 main types of nodes: - Real node - Sentinel node: contains metadata for up to 16 sibling nodes (hash, guardian offset, ...) - Guardian node: contains metadata for up to 16 sibling sentinel nodes (parent, height, sentinels offsets, ... to treat it as a skip list)</p> <p>Now all 3 type of nodes are represented as <code>type NodeUnion = [u8, 16]</code> (more or less), with the actual type encoded in the first <code>u8</code>.</p> <p>I would like now to write a generic function which takes a generic <code>NodeUnion</code> and changes its behaviour according to the actual node type.</p> <p>My questions are: - Could I use an <code>enum</code> but with a custom discriminant, to guarantee packed representation (no more than 128 bits) while reusing Rust idioms? - Should I use the <code>union</code> type instead maybe? Never used those, didn&#39;t know Rust had them, I always used enums before - Should I do a manual casts with <code>as</code> or <code>into</code>? But then I would not use the Rust compiler guarantees in terms of exhaustive matching - Is there another smarter/more idiomatic approach?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/servermeta_net"> /u/servermeta_net </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5bneg/custom_discriminant_for_enum_types/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5bneg/custom_discriminant_for_enum_types/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5b96n/builder_pattern_for_large_structs/" target="_blank">Builder pattern for large structs</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>Edit: Thanks you all for replying , i have found 2 main way one of which i will be implementing this ,</p> <p>Method 1 : using bon crate as said by one of the comments</p> <p>Method 2 : Using a seperate struct which will contain config and then apply builder pattern on that struct rather than on whole struct ,, Like : MyStruct::new(MyStructComfig::new().set_this().set_that());</p> <p>The End ,, No need to reply now</p> <p>i have seen the builder pattern commonly used in rust and what it does is , basically take whole struct by value and return by value ,,</p> <p>I want to use this method in my code by but the thing is that struct is large (almost 7000bytes , it&#39;s a combination of various other structs) and so if i use builder pattern here it will cause huge performance loss , is there any alternative to it?? </p> <p>I want less boiler plate for user side.</p> <p>i want to achieve something like this </p> <p>Details::new()</p> <p>.set_name(&quot;My name&quot;)</p> <p>.set_address(&quot;Some address&quot;)</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/AioliCheap2578"> /u/AioliCheap2578 </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5b96n/builder_pattern_for_large_structs/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5b96n/builder_pattern_for_large_structs/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5as50/compile_time_usize_check/" target="_blank">Compile time usize check</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>We can create a value check on usize at compile time within a trait using something like:</p> <pre><code>const CHECK: () = assert!(usize_a &gt; usize_b); </code></pre> <p>Or</p> <pre><code>const CHECK: usize = (usize_a - usize_b - 1) </code></pre> <p>The former is a regular assert while the latter will underflow usize. Both these techniques work at compile time but require that CHECK appears somewhere in the code path.</p> <p>Is there a way to convert this to a type comparison (please don&#39;t just suggest the typenum crate) so that it doesn&#39;t need to apear in the code path and can be checked at the trait/type definition instead?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/aPieceOfYourBrain"> /u/aPieceOfYourBrain </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r5as50/compile_time_usize_check/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5as50/compile_time_usize_check/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r5aluk/i_made_a_noise_generator_tui/" target="_blank">I made a noise generator TUI</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p>I‚Äôve been wanting a TUI for something like this for a long time. I wasn&#39;t sure why one didn&#39;t exist yet, so I made it myself.</p> <p>I tried to keep it minimal, but it can also download more sounds directly using yt-dlp. I think it is pretty much feature-complete now, though I would like to add more default sounds in the future.</p> <p>here is a link to the repo</p> <p><a href="https://github.com/AnonMiraj/Tanin">https://github.com/AnonMiraj/Tanin</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Aggressive-Smell-432"> /u/Aggressive-Smell-432 </a> <br/> <span><a href="https://i.redd.it/x70z01qdpmjg1.png">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r5aluk/i_made_a_noise_generator_tui/">[comments]</a></span></div>
          </li>
  
          <li>
            <a href="https://www.reddit.com/r/rust/comments/1r552pe/silverfirnano_a_rust_no_std_webassembly/" target="_blank">Silverfir-nano: a Rust no_std WebAssembly interpreter hitting ~67% of single-pass JIT</a>
            <div class="item-content"><!-- SC_OFF --><div class="md"><p><a href="https://preview.redd.it/ieypshtkumjg1.png?width=1320&amp;format=png&amp;auto=webp&amp;s=e4dca07378e779c44b131b72b271a52ae3faf22a">https://preview.redd.it/ieypshtkumjg1.png?width=1320&amp;format=png&amp;auto=webp&amp;s=e4dca07378e779c44b131b72b271a52ae3faf22a</a></p> <p>I‚Äôve been building Silverfir-nano, a WebAssembly 2.0 interpreter focused on speed + tiny footprint.</p> <p>It lands at roughly:</p> <ul> <li>67% of a single-pass JIT (Wasmtime Winch)</li> <li>43% of a full-power Cranelift JIT (Wasmer Cranelift)</li> </ul> <p><del>while keeping the minimal footprint at ~200kb and no-std.</del> // see below</p> <p><a href="https://github.com/mbbill/Silverfir-nano">https://github.com/mbbill/Silverfir-nano</a></p> <p>Edit1: regarding the 200kb size, copy-pasting reply below.</p> <p>&gt;you are going to run ahead of time and then generate more optimized handlers based on that</p> <p>Not exactly, fusion is mostly based on compiler-generated instruction patterns and workload type, not on one specific app binary. Today, across most real programs, compiler output patterns are very similar, and the built-in fusion set was derived from many different apps, not a single target. That is why the default/built-in fusion already captures about ~90% of the benefit for general code. You can push it a bit further in niche cases, but most users do not need per-app fusion.</p> <p>On the benchmark/build question: the headline numbers are from the fusion-enabled configuration, not the ultra-minimal ~200KB build. The ~200KB profile is for maximum size reduction (for example embedded-style constraints), and you should expect roughly ~40% lower performance there (still quite fast tbh, basically wasm3 level).</p> <p>Fusion itself is a size/perf knob with diminishing returns: the full fusion set is about ~500KB, but adding only ~100KB can already recover roughly ~80% of the full-fusion performance. The ~1.1MB full binary also includes std due to the WASI support, so if you do not need WASI you can save several hundred KB more.</p> <p>So number shouldn&#39;t be 200KB but 700KB for maximum performance. thanks for pointing out.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/mbbill"> /u/mbbill </a> <br/> <span><a href="https://www.reddit.com/r/rust/comments/1r552pe/silverfirnano_a_rust_no_std_webassembly/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust/comments/1r552pe/silverfirnano_a_rust_no_std_webassembly/">[comments]</a></span></div>
          </li>
  
        </ul>
  
        <h3 class="subreddit">r/rust_gamedev</h3>
        <ul class="item-list">
  
          <li>
            <a href="https://www.reddit.com/r/rust_gamedev/comments/1r5cgwb/ferroliquid_a_rust_2d_liquid_simulation_ported/" target="_blank">FerroLiquid: A Rust 2D Liquid Simulation (ported from LiquidSketch)</a>
            <div class="item-content"><table> <tr><td> <a href="https://www.reddit.com/r/rust_gamedev/comments/1r5cgwb/ferroliquid_a_rust_2d_liquid_simulation_ported/">  </a> </td><td> <!-- SC_OFF --><div class="md"><p>Hey!</p> <p>About 10 years ago I developed a fluid simulation game for iOS called LiqudSketch (free on <a href="https://apps.apple.com/us/app/liquidsketch/id544717096">iOS Appstore</a>, <a href="https://play.google.com/store/apps/details?id=net.tobiasneukom.liquidsketch">Android Appstore</a>). A while ago I got the urge to start experimenting with fluid dynamics again. I ported the original C++ code to Rust and spent some time experimented with different forces, trying to make demos that looks interesting.</p> <p><a href="https://github.com/tneukom/ferroliquid/">FerroLiquid on GitHub</a></p> <p><a href="https://tneukom.github.io/ferroliquid/">Run in Browser!</a></p> <p>Features:</p> <ul> <li>FLIP fluid simulation with conjugate gradient pressure solver</li> <li>Liquid surface rendering and color advection with OpenGL</li> <li>Integrated debugging visualizers for particle and grid velocities, pressures, ...</li> <li>Placeable widgets for inflows and forces</li> <li>Runs in the browser using WASM</li> </ul> <p>Some notes on what made me switch from C++ to Rust for my personal projects, though I still program C++ at work and enjoy it:</p> <ul> <li>The language itself is (sum types, match, traits, ...) and memory safety are great, but that would not have been enough to make me switch.</li> <li>Iterators: This is the one thing that annoyed me the most and came up quite often when writing C++. Imho iterators/ranges in C++ are hard to use and reason about. I never felt comfortable about memory safety when returning complex ranges. Iterators in Rust on the other hand are easy to use and powerful.</li> <li>Cargo is great! Setting up a project couldn&#39;t be simpler, trying out different libraries is quick. In C++ I try to limit myself to header only libraries, though vcpkg helps.</li> <li>Egui + eframe is fantastic for creative coding on Desktop and Browser. Often the WASM version works right away without any changes.</li> <li>cargo fmt, having a default style everyone uses stops me from thinking about it.</li> </ul> <p>Some negatives:</p> <ul> <li>The VC++ debugger is better than RustRover with LLDB (on Windows). The Rust debugger often skips breakpoints, doesn&#39;t show all local variables, cannot visualize certain data structures well.</li> <li>There doesn&#39;t seem to be an equivalent of Eigen (expression templates) for Rust.</li> </ul> <p>Note: No LLM written code, though it answered a lot of questions.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/Resch1024"> /u/Resch1024 </a> <br/> <span><a href="https://v.redd.it/yoq949806njg1">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/rust_gamedev/comments/1r5cgwb/ferroliquid_a_rust_2d_liquid_simulation_ported/">[comments]</a></span> </td></tr></table></div>
          </li>
  
        </ul>
  
      </div>
  
    </div>
  </body>
  </html>